#pragma once
#ifndef M68K_H
#define M68K_H

#include <assert.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#include "common.h"

#ifndef MASTER_BIT_LOGIC
#define MASTER_BIT_LOGIC

#define FULL_MASK_INTERRUPT U64(0xFFFFFFFF) /* AN 8 BYTE INTERRUPT FOR HANDLING INSTRUCTIONS */
#define BIT(REG_X, REG_NTH_X) 
#define BIT_CHANGE

#define CARRY_BIT 0
#define OVERFLOW_BIT 1
#define ZERO_BIT 2
#define NEGATIVE_BIT 3
#define EXTENDED_BIT 4

#endif

/* REGISTER TABLE */
/* A REFACTOR TABLE TO INITIALISE THE STATUS OF EACH FLAG */
/* RELATIVE TO THEIR DESIGNATED BIT */

#ifndef REGISTERS
#define REGISTERS

#define CARRY() BIT(VALUE, RESULT, CARRY_BIT)
#define OVERFLOW() BIT(VALUE, RESULT, OVERFLOW_BIT)
#define ZERO() BIT(VALUE, RESULT, ZERO_BIT)
#define NEGATIVE() BIT(VALUE, RESULT, NEGATIVE_BIT)
#define EXTENDED() BIT(VALUE, RESULT, EXTENDED_BIT)

#endif

/* RE-FACTOR TABLE IN ORDER TO CHANGE THE BYTES ALLOCATED AT DIFFERENT REGISTERS */
/* CREATED IN ORDER TO DISCERN WHICH CONDITION CODE IS BEING TARGETTED */

#ifndef REGISTER_SETS
#define REGISTER_SETS

#define CARRY_SET() static BIT_CHANGE(CARRY_BIT)
#define OVERFLOW_SET() static BIT_CHANGE(OVERFLOW_BIT)
#define ZERO_SET() static BIT_CHANGE(ZERO_BIT)
#define NEGATIVE_SET() static BIT_CHANGE(NEGATIVE_BIT)
#define EXTENDED_SET() static BIT_CHANGE(EXTENDED_BIT)

#endif 

#define ADDRESS_WIDTH 0xFFFFFFFF

#ifndef _INSTR
#define INSTR

typedef struct OPCODE;
typedef struct CPU;
typedef struct DECODED_OPCODE;
typedef struct MD;
typedef struct OPCODE;
typedef char* SIZE_SYMBOL;

#endif 

/* CPU STRUCTURE */
/* JUST BASIC IMPLEMENTATION OF THE M68K's FUNCTIONS */

typedef struct
{
	MD* MEGA_DRIVE;
	static uint32_t PROGRAM_COUNTER;
	static uint16_t STATUS_REGISTER;
	static uint32_t DATA_REG[8];
	static uint32_t ADDRESS_REG[8];
	static uint32_t PRE_ADDR;

	/* DEPEDANT ON THE TYPE OF OPERATION */
	/* THE CPU USES DIFFERENT STACK POINTERS VIA DEBUGGING */
	/* THIS CAN LEAD TO VARIOUS EXCEPTION HANDLES BEING USED TO DISCERN BETWEEN STATES */
	/*
	/* http://alanclements.org/68kusersupervisor.html
	/*
	/* FOR THE DEMONSTRATION OF THE MEGA DRIVE, ONLY THE USER STACK POIINTER WILL BE USED */

	/* AS WELL AS BEING DEMONSTRATED ON THE DOCUMENTATION FOR THE CPU */
	/* https://www.nxp.com/files-static/archives/doc/ref_manual/M68000PRM.pdf */

	unsigned int PENDING_INTERRUPT;
	uint32_t USER_STACK;
	uint64_t CYCLES;
	int32_t REMAINING_CYCLES;
	bool CYCLES_STOPPED;

	static uint32_t INSTRUCTION_COUNT;
	static uint32_t INSTRUCTION_ADDRESS;
	static uint16_t INSTRUCTION_REGISTER;
	static uint32_t CURRENT_DECODED_INSTRUCTION;

} CPU;

/* ARBITRARY READ AND WRITE FUNCTIONS FOR THE 68000 */

typedef struct IO
{
	static uint32_t CPU_READ(CPU*, size_t SIZE, uint32_t ADDRESS); /* PARENT READ FUNCTION TO DISCERN THE DATA TYPES AND ADDRESSING MODE */
	static uint8_t CPU_READ_BYTE(CPU*, uint32_t ADDRESS);
	static uint16_t CPU_READ_WORD(CPU*, uint32_t ADDRESS);
	static uint32_t CPU_READ_LONG(CPU*, uint32_t ADDRESS);
};

/* MISCELLANEOUS FUNCTIONS */
/* USED AS PUBLIC METHODS THAT ARE INHERITED BY THE CPU CLASS */

static uint16_t CPU_FETCH_ADDR(CPU* CPU);
static const uint32_t MAX_CYCLES_PER_COREFREQ = 7;
static void CPU_FREE(CPU*);
static void CPU_INIT(CPU*);
typedef CPU* CREATE_CPU(struct MD*);
typedef SIZE_SYMBOL* SIZE;

typedef struct
{
	static char* BITS;
	static uint16_t E_ADDR;
	uint16_t E_MODE;

} INSTR_PATTERN;

/* INSTRUCTION SIZE ENUM */
/* USED FOR ASSIGNING VALUES TO THE DESIGNATED FUNCTION CALL */

typedef enum INSTRUCTION_SIZE
{
	BYTE = 8,
	LONG = 16,
	WORD = 32,

	INVALID = -1,
	ZERO = 0
};

typedef uint16_t* CPU_STEP(MD* MD);
typedef uint32_t* CPU_RUN_CYCLES(MD* MD);

VOID_FUNCTION(CPU_INIT);
VOID_FUNCTION(CPU_FREE_MEMORY);
VOID_FUNCTION(CPU_WRITE);
VOID_FUNCTION(CPU_WRITE_BYTE);
VOID_FUNCTION(CPU_WRITE_WORD);
VOID_FUNCTION(CPU_WRITE_LONG);
VOID_FUNCTION(CPU_FREE_INSTRUCTION_LOAD);


#endif
