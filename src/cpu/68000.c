/* Copyright (C) 2023 Harry Clark */

/* SEGA Mega Drive Emulator */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONS OF THE CPU */

#include "68000.h"
#include "instruction.h"

static MD* MEGA_DRIVE;

/* ALLOCATE THE REQUESTED MEMORY */
/* USING THE CALLOC FUNCTION TO CREATE A POINTER */

static CPU* CREATE_CPU(struct CPU* CPU)
{
        assert(sizeof(CPU));
	return CPU;
}

/* BASE CASE FOR DEALLOCATING OR REALLOCATING MEMORY */

static void CPU_FREE_MEMORY(CPU* MEM)
{
	free(MEM);
}

/* A REFACTOR FUNCTION TO DECLARE THE CPU'S QUINTESSENTIAL FUNCTIONS */
/* ALL OF WHICH ARE CITED FROM https://www.nxp.com/files-static/archives/doc/ref_manual/M68000PRM.pdf */

static void CPU_INIT(struct CPU* CPU, struct IO* CPU_IO)
{
	CPU->STATUS_REGISTER = 0x000000;
	CPU->ADDRESS_REG[7] = CPU_IO->CPU_READ_LONG(CPU, 0);
	CPU->PROGRAM_COUNTER = CPU_IO->CPU_READ_LONG(CPU, 4);
	CPU->CYCLES = 0;
	CPU->CYCLES_STOPPED = false;
	CPU->REMAINING_CYCLES = 0;
	CPU->PENDING_INTERRUPT = -1;
	CPU->PRE_ADDR = 0;
}

/* DECODE INSTRUCTION BASED ON THE INFORMATION THAT IS BEING */
/* FED TO EACH RESPECTIVE REGISTERS */

/* THE PC COMPRISES OF THE CURRENT INSTRUCTION THAT IS BEING EXECUTED */
/* THIS ALLOWS FOR POINTER BASED ADDRESSING HENCE THE REFACTORISATION */

static void DECODE_CPU_INSTR(CPU* CPU, U32 INSTRUCTION_ADDR)
{
	U32 PROGRAM_COUNTER = CPU->PROGRAM_COUNTER;
	U16 INSTRUCTION_REGISTER = CPU->INSTRUCTION_REGISTER;
	U32 INSTRUCTION_ADDRESS = CPU->INSTRUCTION_ADDRESS;

	U16 OPERATION = CPU_FETCH_ADDR(CPU);

	CPU->INSTRUCTION_ADDRESS = INSTRUCTION_ADDR;
	CPU->INSTRUCTION_REGISTER = INSTRUCTION_ADDR;
	CPU->PROGRAM_COUNTER = INSTRUCTION_ADDR;
	
	DECODED_OPCODE* DECODE = nullptr;
	OPCODE* OPCODE_INSTR;

}

static void CPU_FREE_INSTRUCTION_LOAD(DECODED_OPCODE* DECODED)
{
	if (DECODED == NULL) return;
	free(DECODED);
}

static U32* RUN_CYCLES(CPU* CPU, U32 CYCLES, U64 CYCLES_PER_FRAME)
{
	CYCLES_PER_FRAME = 0;
	CPU->REMAINING_CYCLES += CYCLES;
}

static U16* STEP_COROUTINE(MD* MD, CPU* CPU)
{
	CPU->PROGRAM_COUNTER >= sizeof(ADDRESS_WIDTH);
	CPU->PROGRAM_COUNTER % 2 == 0;
	CPU->ADDRESS_REG[7] % 2 == 0;
	CPU->INSTRUCTION_ADDRESS += sizeof(CPU->PROGRAM_COUNTER);
}

static bool HANDLE_INTERRUPT(CPU* CPU)
{
	if (CPU->PENDING_INTERRUPT < 0) return false;
	DEBUG_LOG("CPU Interrupt %d handled\n", CPU->PENDING_INTERRUPT);

	CPU->PENDING_INTERRUPT = -1;

	return;
}
