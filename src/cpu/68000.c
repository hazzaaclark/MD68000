/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONS OF THE CPU */

#include "68000.h"

#undef USE_CPU

#if defined(M68K_CPU_ARGS)
#define	M68K_CPU_ARGS
#else
#define M68K_CPU_ARGS

#define		M68K_CALLBACK_RESET			1
#define		M68K_CALLBACK_FUNC			2

#endif

/* DISCERN THE RUDIMENTARY AMOUNT OF CPU CYCLES */
/* THE CPU WILL GOVERN OVER THE COURSE OF IT'S RUN TIME */

/* THIS WILL ENCOMPASS THE WIDE BITWISE VARIETY */
/* THROUGH THE CONCISE MEANS OF EVALUATING THE SIZE OF */
/* OF THE DESIGNATED MEMORY */

/* SEE 1.1 USER PROGRAMMING MODEL https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf#page=13 */

void INITIALISE_68K_CYCLES(char* CPU_68K_CYCLES)
{
	CPU_68K_CYCLES = malloc(sizeof(CPU_68K_CYCLES));

	/* THIS LOOP WILL CHECK FOR EVERY SUBSEQUENT BITWISE */
	/* OPERATION AND EVALUATE IT'S DESIGNATED MEMORY */

	/* THE FIRST CO-EFFICIENT REPRESENTS THE BITWISE LENGTH OF THE OPERATION */
	/* THE SECOND CO-EFFICIENT REPRESENTS THE SIZE OF THE REGISTER */

	for (size_t INDEX = 0; INDEX < sizeof(CPU_68K_CYCLES); INDEX++)
	{
		switch (INDEX / 16)
		{
		case 0:
			CPU_68K_CYCLES[INDEX] = 8*7;
			break;

		case 1:
			CPU_68K_CYCLES[INDEX] = 16*7;
			break;

		case 2:
			CPU_68K_CYCLES[INDEX] = 24*7;

		default:
			CPU_68K_CYCLES[INDEX] = 32*7;
			break;
		}
	}
}

/* ACCESS EACH RESPECTIVE REGISTER FROM THE ENUMERATION */
/* RETURN THE CORRESPONDENCE IN RELATION TO THE SIZE */

/* FOR EASE OF USE WHEN ACCESSING METHODS, I HAVE CREATED A MACRO */
/* TO BE ABLE TO RETURN THE CORRESPONDING ADDRESS VALUE IN RELATION */
/* TO THE INDEXXING OF THE REGISTER ARRAY */

unsigned int CPU_ACCESS_REGISTERS(CPU_68K_REGS REGISTER, unsigned VALUE)
{
	struct CPU_68K* CPU_68K;

	/* IF THERE IS NO ACCESSIBLE METHODS */
	/* WE SPECIFICALLY ALLOCATE MEMORY SAID ACCESSING OF REGISTERS */

	if(!CPU_68K)
		CPU_68K = malloc(sizeof(CPU_68K));

	switch(REGISTER)
	{
		case M68K_REG_D0: return CPU_68K->REGISTER_BASE[0] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D1: return CPU_68K->REGISTER_BASE[1] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D2: return CPU_68K->REGISTER_BASE[2] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D3: return CPU_68K->REGISTER_BASE[3] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D4: return CPU_68K->REGISTER_BASE[4] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D5: return CPU_68K->REGISTER_BASE[5] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D6: return CPU_68K->REGISTER_BASE[6] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D7: return CPU_68K->REGISTER_BASE[7] = M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_A0: return CPU_68K->REGISTER_BASE[8] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A1: return CPU_68K->REGISTER_BASE[9] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A2: return CPU_68K->REGISTER_BASE[10] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A3: return CPU_68K->REGISTER_BASE[11] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A4: return CPU_68K->REGISTER_BASE[12] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A5: return CPU_68K->REGISTER_BASE[13] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A6: return CPU_68K->REGISTER_BASE[14] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A7: return CPU_68K->REGISTER_BASE[15] = M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_PC: return M68K_RETURN_ADDRESS(CPU_68K->PC);

		case M68K_REG_USP:
			if(FLAG_S) CPU_68K->REGISTER_BASE[15] = M68K_RETURN_ADDRESS(VALUE);
			return;

		case M68K_REG_ISP:
			if(FLAG_S) CPU_68K->REGISTER_BASE[14] = M68K_RETURN_ADDRESS(VALUE);
			return;

		default: 
			return M68K_RETURN_ADDRESS(VALUE);	
	}
}

/* INITALISE THE CPU BY ASSUMING THAT THE LOOKUP TABLE */
/* HAS BEEN CREATED */

/* THE FIRST CALL OF THE FUNCTION ALSO INITIALISES THE OPCODE HANDLER */
/* WHAT THIS MEANS IN TERMS OF REAL HARDWARE IS USING THE JMP DIRECTIVE */
/* TO DETERMINE WHICH CARTRIDGE IS BEING ALLOCATED TO THE HEADER */

void M68K_INIT(void)
{
	#ifndef BUILD_68K_TABLES
		M68K_INIT_OPCODE(NULL);
	#endif

	M68K_SET_INT_CALLBACK(NULL);
}

/* INTIALISE THE INTEGER TYPE CALLBACK */
/* THIS CALLBACK REFERS TO THE WAY IN WHICH THE DESIGNATED TYPE */
/* IS ABLE TO COMMUNICATE BETWEEN ALL AREAS OF EACH RESPECTIVE REGISTER */

/* SEE: https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf#page=14 */

/* ALLOCATE A DESIGNATED CHUNK OF MEMORY ASSUMING THE NOTION */
/* THAT THE RESPECTIVE REGISTER NEEDS TO ACCESS VALUES OF THIS ASSOCIATION */

#undef M68K_CPU_ARGS

void M68K_SET_INT_CALLBACK()
{
	return sizeof(&M68K_CALLBACK_INT);
}

/* FOLLOWING ON FROM THE SAME PRINCIPLES AS ABOVE */
/* INITIALISE THE REMAINING CALLBACKS */

void M68K_SET_FUNC_CALLBACK()
{
	return sizeof(&M68K_FUNC_CALLBACK);
}

/* DETERMINE THE STEP LATENCY OF RELEVANT MOVE BASED INSTRUCTIONS */
/* THIS CHECKS THE MASK TO PROCESS SAID IRQ */

void M68K_SET_MOVE_IRQ_INT(unsigned VALUE)
{
	struct CPU_68K* CPU_68K;

	/* FIRSTLY, WE BEGIN TO EVALUATE THE SIZE OF THE CURRENTLY EXECUTED INSTRUCTION */
	/* THIS IS SO THAT WHEN CHECKING THE MASK, WE DON'T RUN INTO BUFFER OVERFLOWS */

	assert(CPU_68K->PC <= ADDRESS_WIDTH_32);
	assert(CPU_68K->MEMORY_ADDRESS[7] % 2 == 0);

	/* SECONDLY, EVALUATE WHICH INSTRUCTION IS BEING EXECUTED */
	/* CREATE A CAST TO EVALUATE THE SIZE OF THE RELEVANT INSTRUCTION */

	CPU_68K->INSTRUCTION_REGISTER = (U16*)malloc(M68K_FETCH_INSTR(&CPU_68K));

	/* THIRDLY, EVALUATE THE STEP LATENCY TO DETERMINE THE EXECUTION TIME */	
	/* THIS IS BY ASSUMING THAT THE CORRESPONDING INSTRUCTION HAS A RELATIVE SIZE */

	/* FROM THERE, DETERMINE IF THE INSTRUCTION CAN BE OR IS HOUSED IN THE INDEX REGISTER */
	/* IF NOT, MAKE ROOM FOR THE CURRENT INDEX */

	int IRQ_LATENCY;
	int INT_LEVEL;

	if(!IRQ_LATENCY && M68K_REG_IR & 0xF000 != 0x2000) 
	{
		M68K_CYCLE_CLOCK_SHIFT(CPU_68K->INSTRUCTION_CYCLES[M68K_REG_IR]);
	}

	INT_LEVEL <= 8;
}

void M68K_RUN(void)
{
	struct CPU_68K* CPU_68K;
	int CYCLES;

	/* WHILE WORKING, CHECK IF THE INSTRUCTION CYCLES */
	/* MATCHES THE CORRESPONDNECE IN THE CYCLE CACHE */

	if(CPU_68K->INSTRUCTION_CYCLES >= CYCLES)
	{
		return;
	}

	/* EXECUTE RELEVANT INSTRUCTION */

	CPU_68K->INSTRUCTION_REGISTER[M68K_REG_IR];
	M68K_CYCLE_CLOCK_SHIFT(CPU_68K->INSTRUCTION_CYCLES[M68K_REG_IR]);

}

/* BASED ON THE FUNCTIONALITY ABOVE, WE CAN BEGIN TO EVALUATE WHICH INSTRUCTIONS ARE BEING FETCHED */
/* THIS IS BASED ON THEIR PRIORITY LEVEL IN RELATION TO WHICH INSTRUCTION IS BEING FETCHED FROM THE PC */

U16* M68K_FETCH_INSTR(struct CPU_68K* CPU_68K)
{
	unsigned WORD;

	/* IF THE PROGRAM COUNTER HAS JUMPED TO ANOTHER SUBROUTINE */
	/* OR INSTRUCTION, SHIFT LOGICAL TO THE NEXT PROBABLE INSTRUCTION */

	if(CPU_68K->PC != CPU_68K->PREVIOUS_ADDRESS)
	{
		WORD = M68K_READ_16(CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_DATA);
		CPU_68K->PC = CPU_68K->PREVIOUS_ADDRESS, sizeof(CPU_68K->PC + 2);
	}

	return WORD;
}
