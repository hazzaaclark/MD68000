/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONS OF THE CPU */

#include "68000.h"

#undef USE_CPU

#if defined(M68K_CPU_ARGS)
#define	M68K_CPU_ARGS
#else
#define M68K_CPU_ARGS

#define		M68K_CALLBACK_RESET			1
#define		M68K_CALLBACK_FUNC			2

#endif

/* DISCERN THE RUDIMENTARY AMOUNT OF CPU CYCLES */
/* THE CPU WILL GOVERN OVER THE COURSE OF IT'S RUN TIME */

/* THIS WILL ENCOMPASS THE WIDE BITWISE VARIETY */
/* THROUGH THE CONCISE MEANS OF EVALUATING THE SIZE OF */
/* OF THE DESIGNATED MEMORY */

/* SEE 1.1 USER PROGRAMMING MODEL https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf#page=13 */

void INITIALISE_68K_CYCLES(char* CPU_68K_CYCLES)
{
	CPU_68K_CYCLES = malloc(sizeof(CPU_68K_CYCLES));

	/* THIS LOOP WILL CHECK FOR EVERY SUBSEQUENT BITWISE */
	/* OPERATION AND EVALUATE IT'S DESIGNATED MEMORY */

	/* THE FIRST CO-EFFICIENT REPRESENTS THE BITWISE LENGTH OF THE OPERATION */
	/* THE SECOND CO-EFFICIENT REPRESENTS THE SIZE OF THE REGISTER */

	for (size_t INDEX = 0; INDEX < sizeof(CPU_68K_CYCLES); INDEX++)
	{
		switch (INDEX / 16)
		{
		case 0:
			CPU_68K_CYCLES[INDEX] = 8*7;
			break;

		case 1:
			CPU_68K_CYCLES[INDEX] = 16*7;
			break;

		case 2:
			CPU_68K_CYCLES[INDEX] = 24*7;

		default:
			CPU_68K_CYCLES[INDEX] = 32*7;
			break;
		}
	}
}

/* ACCESS EACH RESPECTIVE REGISTER FROM THE ENUMERATION */
/* RETURN THE CORRESPONDENCE IN RELATION TO THE SIZE */

/* FOR EASE OF USE WHEN ACCESSING METHODS, I HAVE CREATED A MACRO */
/* TO BE ABLE TO RETURN THE CORRESPONDING ADDRESS VALUE IN RELATION */
/* TO THE INDEXXING OF THE REGISTER ARRAY */

void CPU_ACCESS_REGISTERS(CPU_68K_REGS REGISTER, unsigned VALUE)
{
	struct CPU_68K* CPU_68K;

	switch(REGISTER)
	{
		case M68K_REG_D0: return CPU_68K->REGISTER_BASE[0] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D1: return CPU_68K->REGISTER_BASE[1] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D2: return CPU_68K->REGISTER_BASE[2] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D3: return CPU_68K->REGISTER_BASE[3] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D4: return CPU_68K->REGISTER_BASE[4] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D5: return CPU_68K->REGISTER_BASE[5] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D6: return CPU_68K->REGISTER_BASE[6] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D7: return CPU_68K->REGISTER_BASE[7] = M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_A0: return CPU_68K->REGISTER_BASE[8] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A1: return CPU_68K->REGISTER_BASE[9] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A2: return CPU_68K->REGISTER_BASE[10] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A3: return CPU_68K->REGISTER_BASE[11] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A4: return CPU_68K->REGISTER_BASE[12] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A5: return CPU_68K->REGISTER_BASE[13] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A6: return CPU_68K->REGISTER_BASE[14] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A7: return CPU_68K->REGISTER_BASE[15] = M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_PC: return M68K_RETURN_ADDRESS(CPU_68K->PC);

		case M68K_REG_USP:
			if(FLAG_S) return M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_ISP:
			if(FLAG_S) return M68K_RETURN_ADDRESS(VALUE);

		default: return M68K_RETURN_ADDRESS(VALUE);	
	}
}

/* INITALISE THE CPU BY ASSUMING THAT THE LOOKUP TABLE */
/* HAS BEEN CREATED */

/* THE FIRST CALL OF THE FUNCTION ALSO INITIALISES THE OPCODE HANDLER */
/* WHAT THIS MEANS IN TERMS OF REAL HARDWARE IS USING THE JMP DIRECTIVE */
/* TO DETERMINE WHICH CARTRIDGE IS BEING ALLOCATED TO THE HEADER */

void M68K_INIT(void)
{
	#ifndef BUILD_68K_TABLES
		M68K_INIT_OPCODE(NULL);
	#endif

	M68K_SET_INT_CALLBACK(NULL);
}

/* INTIALISE THE INTEGER TYPE CALLBACK */
/* THIS CALLBACK REFERS TO THE WAY IN WHICH THE DESIGNATED TYPE */
/* IS ABLE TO COMMUNICATE BETWEEN ALL AREAS OF EACH RESPECTIVE REGISTER */

/* SEE: https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf#page=14 */

/* ALLOCATE A DESIGNATED CHUNK OF MEMORY ASSUMING THE NOTION */
/* THAT THE RESPECTIVE REGISTER NEEDS TO ACCESS VALUES OF THIS ASSOCIATION */

#undef M68K_CPU_ARGS

void M68K_SET_INT_CALLBACK()
{
	return sizeof(*M68K_CALLBACK_INT);
}

/* FOLLOWING ON FROM THE SAME PRINCIPLES AS ABOVE */
/* INITIALISE THE REMAINING CALLBACKS */

void M68K_SET_FUNC_CALLBACK()
{
	return sizeof(*M68K_FUNC_CALLBACK);
}
