/* Copyright (C) 2023 Harry Clark */

/* SEGA Mega Drive Emulator */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONS OF THE CPU */

#include "68000.h"
#include "instruction.h"

#undef USE_CPU

/* DISCERN THE RUDIMENTARY AMOUNT OF CPU CYCLES */
/* THE CPU WILL GOVERN OVER THE COURSE OF IT'S RUN TIME */

/* THIS WILL ENCOMPASS THE WIDE BITWISE VARIETY */
/* THROUGH THE CONCISE MEANS OF EVALUATING THE SIZE OF */
/* OF THE DESIGNATED MEMORY */

/* SEE 1.1 USER PROGRAMMING MODEL https://www.nxp.com/docs/en/reference-manual/M68000PRM.pdf#page=13 */

#undef BUILD_68K_TABLES

STATIC
void INITIALISE_68K_CYCLES(char* CPU_68K_CYCLES[0x10000])
{
	CPU_68K_CYCLES = malloc(sizeof(CPU_68K_CYCLES));
	S32 INDEX;

	/* THIS LOOP WILL CHECK FOR EVERY SUBSEQUENT BITWISE */
	/* OPERATION AND EVALUATE IT'S DESIGNATED MEMORY */

	/* THE FIRST CO-EFFICIENT REPRESENTS THE BITWISE LENGTH OF THE OPERATION */
	/* THE SECOND CO-EFFICIENT REPRESENTS THE SIZE OF THE REGISTER */

	for (INDEX = 0; INDEX < sizeof(CPU_68K_CYCLES); INDEX++)
	{
		switch (INDEX / 16)
		{
		case 0:
			CPU_68K_CYCLES[INDEX] = 8*7;
			break;

		case 1:
			CPU_68K_CYCLES[INDEX] = 16*7;
			break;

		case 2:
			CPU_68K_CYCLES[INDEX] = 24*7;

		default:
			CPU_68K_CYCLES[INDEX] = 32*7;
			break;
		}
	}
}

/* ACCESS EACH RESPECTIVE REGISTER FROM THE ENUMERATION */
/* RETURN THE CORRESPONDENCE IN RELATION TO THE SIZE */

/* FOR EASE OF USE WHEN ACCESSING METHODS, I HAVE CREATED A MACRO */
/* TO BE ABLE TO RETURN THE CORRESPONDING ADDRESS VALUE IN RELATION */
/* TO THE INDEXXING OF THE REGISTER ARRAY */

STATIC 
unsigned CPU_ACCESS_REGISTERS(CPU_68K_REGS REGISTER, CPU_68K_FLAGS FLAGS, unsigned VALUE)
{
	struct CPU_68K* CPU_68K;

	switch(REGISTER)
	{
		case M68K_REG_D0: return CPU_68K->REGISTER_BASE[0] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D1: return CPU_68K->REGISTER_BASE[1] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D2: return CPU_68K->REGISTER_BASE[2] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D3: return CPU_68K->REGISTER_BASE[3] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D4: return CPU_68K->REGISTER_BASE[4] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D5: return CPU_68K->REGISTER_BASE[5] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D6: return CPU_68K->REGISTER_BASE[6] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_D7: return CPU_68K->REGISTER_BASE[7] = M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_A0: return CPU_68K->REGISTER_BASE[8] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A1: return CPU_68K->REGISTER_BASE[9] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A2: return CPU_68K->REGISTER_BASE[10] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A3: return CPU_68K->REGISTER_BASE[11] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A4: return CPU_68K->REGISTER_BASE[12] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A5: return CPU_68K->REGISTER_BASE[13] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A6: return CPU_68K->REGISTER_BASE[14] = M68K_RETURN_ADDRESS(VALUE);
		case M68K_REG_A7: return CPU_68K->REGISTER_BASE[15] = M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_PC: return M68K_RETURN_ADDRESS(CPU_68K->PC);

		case M68K_REG_USP:
			if(FLAG_S) return M68K_RETURN_ADDRESS(VALUE);

		case M68K_REG_ISP:
			if(FLAG_S) return M68K_RETURN_ADDRESS(VALUE);

		default: return M68K_RETURN_ADDRESS(VALUE);	
	}
}

/* INITALISE THE CPU BY ASSUMING THAT THE LOOKUP TABLE */
/* HAS BEEN CREATED */

/* THE FIRST CALL OF THE FUNCTION ALSO INITIALISES THE OPCODE HANDLER */
/* WHAT THIS MEANS IN TERMS OF REAL HARDWARE IS USING THE JMP DIRECTIVE */
/* TO DETERMINE WHICH CARTRIDGE IS BEING ALLOCATED TO THE HEADER */

STATIC
void M68K_INIT(void)
{
	#if BUILD_68K_TABLES
		M68K_INIT_OPCODE();
	#endif
}

