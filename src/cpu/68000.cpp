/* Copyright (C) 2023 Harry Clark */

/* SEGA Mega Drive Emulator */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONS OF THE CPU */

#include "68000.h"
#include "instruction.h"

/* ALLOCATE THE REQUESTED MEMORY */
/* USING THE CALLOC FUNCTION TO CREATE A POINTER */

static CPU* CREATE_CPU(MD* MD)
{
	calloc(1, sizeof(CPU));
	CPU::MEGA_DRIVE* MEGA_DRIVE;
	return;
}

/* BASE CASE FOR DEALLOCATING OR REALLOCATING MEMORY */

static void CPU_FREE_MEMORY(CPU* MEM)
{
	free(MEM);
}

/* A REFACTOR FUNCTION TO DECLARE THE CPU'S QUINTESSENTIAL FUNCTIONS */
/* ALL OF WHICH ARE CITED FROM https://www.nxp.com/files-static/archives/doc/ref_manual/M68000PRM.pdf */

static void CPU_INIT(CPU* CPU)
{
	CPU->STATUS_REGISTER = 0x2700;
	CPU->ADDRESS_REG[7] = IO::CPU_READ_LONG(CPU, 0);
	CPU->PROGRAM_COUNTER = IO::CPU_READ_LONG(CPU, 4);
	CPU->CYCLES = 0;
	CPU->CYCLES_STOPPED = false;
	CPU->REMAINING_CYCLES = 0;
	CPU->PENDING_INTERRUPT = -1;
	CPU->PRE_ADDR;
}

/* DECODE INSTRUCTION BASED ON THE INFORMATION THAT IS BEING */
/* FED TO EACH RESPECTIVE REGISTERS */

/* THE PC COMPRISES OF THE CURRENT INSTRUCTION THAT IS BEING EXECUTED */
/* THIS ALLOWS FOR POINTER BASED ADDRESSING HENCE THE REFACTORISATION */

static DECODED_OPCODE* DECODE_CPU_INSTR(CPU* CPU, U32 INSTRUCTION_ADDR)
{
	U32 PROGRAM_COUNTER = CPU->PROGRAM_COUNTER;
	U16 INSTRUCTION_REGISTER = CPU->INSTRUCTION_REGISTER;
	U32 INSTRUCTION_ADDRESS = CPU->INSTRUCTION_ADDRESS;

	U16 OPERATION = CPU_FETCH_ADDR(CPU);

	CPU->INSTRUCTION_ADDRESS = INSTRUCTION_ADDR;
	CPU->INSTRUCTION_REGISTER = INSTRUCTION_ADDR;
	CPU->PROGRAM_COUNTER = INSTRUCTION_ADDR;
	
	DECODED_OPCODE* DECODE = nullptr;
	OPCODE* OPCODE_INSTR;

}


static void CPU_FREE_INSTRUCTION_LOAD(DECODED_OPCODE* DECODED)
{
	if (DECODED == NULL) return;
	free(DECODED);
}

static inline CPU_RUN_CYCLES* RUN_CYCLES(CPU* CPU, U32 CYCLES, U64 CYCLES_PER_FRAME)
{
	CYCLES_PER_FRAME = 0;
	CPU->REMAINING_CYCLES += CYCLES;
}

static inline CPU_STEP* STEP_COROUTINE(MD* MD)
{
	CPU::PROGRAM_COUNTER <= ADDRESS_WIDTH;
	CPU::PROGRAM_COUNTER % 2 == 0;
	CPU::ADDRESS_REG[7] % 2 == 0;
	CPU::INSTRUCTION_ADDRESS == CPU::PROGRAM_COUNTER;

	bool INTERRUPTED;
}

static inline IO::HANDLE_INTERRUPT* HANDLE_INTERRUPT(CPU* CPU)
{
	if (CPU->PENDING_INTERRUPT < 0) return false;
	DEBUG_LOG("CPU Interrupt %d handled\n", CPU->PENDING_INTERRUPT);

	CPU->PENDING_INTERRUPT = -1;

	return;
}
