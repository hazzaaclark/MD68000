/* Copyright (C) 2023 Harry Clark */

/* SEGA Mega Drive Emulator */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONS OF THE CPU */

#include "68000.h"
#include "instruction.h"

#ifdef DEBUG
#define DEBUG_LOG(...) (__VA_ARGS__)
#else
#define DEBUG_LOG()
#endif

#define MODE_MASK(MODE) (1 << MODE)

/* ALLOCATE THE REQUESTED MEMORY */
/* USING THE CALLOC FUNCTION TO CREATE A POINTER */

static CPU* CREATE_CPU(MD* CONSOLE)
{
	calloc(1, sizeof(CPU));
	return;
}

/* BASE CASE FOR DEALLOCATING OR REALLOCATING MEMORY */

static void CPU_FREE_MEMORY(CPU* MEM)
{
	free(MEM);
}

/* A REFACTOR FUNCTION TO DECLARE THE CPU'S QUINTESSENTIAL FUNCTIONS */
/* ALL OF WHICH ARE CITED FROM https://www.nxp.com/files-static/archives/doc/ref_manual/M68000PRM.pdf */

static void CPU_INIT(CPU* CPU)
{
	CPU->STATUS_REGISTER = 0x2700;
	CPU->ADDRESS_REG[7] = IO::CPU_READ_LONG(CPU, 0);
	CPU->PROGRAM_COUNTER = IO::CPU_READ_LONG(CPU, 4);
	CPU->CYCLES = 0;
	CPU->CYCLES_STOPPED = false;
	CPU->REMAINING_CYCLES = 0;
	CPU->PENDING_INTERRUPT = -1;
	CPU->PRE_ADDR;
}

/* DECODE INSTRUCTION BASED ON THE INFORMATION THAT IS BEING */
/* FED TO EACH RESPECTIVE REGISTERS */

/* THE PC COMPRISES OF THE CURRENT INSTRUCTION THAT IS BEING EXECUTED */
/* THIS ALLOWS FOR POINTER BASED ADDRESSING HENCE THE REFACTORISATION */

static DECODED_OPCODE* DECODE_CPU_INSTR(CPU* CPU, uint32_t INSTRUCTION_ADDR)
{
	uint32_t PROGRAM_COUNTER = CPU->PROGRAM_COUNTER;
	uint16_t INSTRUCTION_REGISTER = CPU->INSTRUCTION_REGISTER;
	uint32_t INSTRUCTION_ADDRESS = CPU->INSTRUCTION_ADDRESS;

	uint16_t OPERATION = CPU_FETCH_ADDR(CPU);

	CPU->INSTRUCTION_ADDRESS = INSTRUCTION_ADDR;
	CPU->INSTRUCTION_REGISTER = INSTRUCTION_ADDR;
	CPU->PROGRAM_COUNTER = INSTRUCTION_ADDR;
	
	DECODED_OPCODE* DECODE = nullptr;
	OPCODE* OPCODE_INSTR;

}


static void CPU_FREE_INSTRUCTION_LOAD(DECODED_OPCODE* DECODED)
{
	if (DECODED == NULL) return;
	free(DECODED);
}

static uint32_t CPU_CYCLES(CPU* CPU, uint32_t CYCLES, uint64_t CYCLES_PER_FRAME)
{
	CYCLES_PER_FRAME = 0;
	CPU->REMAINING_CYCLES += CYCLES;
}

static inline CPU_STEP* STEP_COROUTINE(MD* MD)
{
	CPU::PROGRAM_COUNTER <= ADDRESS_WIDTH;
	CPU::PROGRAM_COUNTER % 2 == 0;
	CPU::ADDRESS_REG[7] % 2 == 0;
	CPU::INSTRUCTION_ADDRESS == CPU::PROGRAM_COUNTER;
}
