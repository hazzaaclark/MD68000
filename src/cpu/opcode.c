/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TOWARDS THE CONJUNCTIVE FUNCTIONALITY */
/* BETWEEN THE 68000 AND Z80 - PERTAINING TOWARDS OPCODES */
/* THAT ARE USED TO DETERMINE INSTRUCTION AND EXECUTION METHODS */

/* NESTED INCLUDES */

#include "68000.h"

#undef USE_OPCODE_DEFS

/* GENERATE A GENERIC TYPE BASED ON RELEVANT INSTRUCTION LENGTH */
/* INSTRUCTION MODE, INSTRUCTION SPLIT MASK, ETC */

/* IN M68000 ASSEMBLY, OPCODES ARE GOVERNED ON THE BASIS OF CERTAIN OPERANDS MODES */
/* WHICH CAN VARY BASED ON THEIR BITWISE LENGTH */

/* SEE 68000.h FOR DETAILS PERTAINING TOWARDS OPERAND TYPES */

OPCODE* GENERATE_OPCODE(const OPCODE* OPCODE, int* MAP)
{
    /* ITERATE THROUGH THE RESPECTIVE ELEMENTS OF THE OPERAND */
    /* BASED ON THEIR MAP PATTERN */

    /* IF THE FOLLOWING OPCODE RELATES TO THE OPERAND IN THE INDEX */
    /* RETURN THE CORRESPONDENCE ASSUMING THEIR BITWISE LENGTH MATCHES */

    int INDEX;

    for (INDEX = 0; INDEX < MAP; INDEX++)
    {
        if((OPCODE->OPERAND.INDEX_REGISTER && OPCODE[INDEX].PATTERN) == sizeof(OPCODE[INDEX].PATTERN))
        {
            return OPCODE[INDEX].OPERAND.LITERAL;
        }
    }

    return OPERAND_NONE; /* BY DEFAULT, NO INSTRUCTION WILL BE PROCESSED */   
    
};

/* THIS FUNCTION WILL GOVERN THE BASIS FOR WHICH THE OPCODE MAPS */
/* WILL BE GIVEN SPECIFIC VALUES */

/* EACH RESPECTIVE OPCODE WILL BE DETERMINED ON THE BASIS OF SEVERAL FACTORS */
/*      FUNCTION TYPE                                                       */
/*      MASK BITS                                                           */
/*      MATCH                                                               */
/*      OFFSETS                                                             */

OPCODE OPCODE_HANDLER_TABLE[] =
{
    {OPCODE_MOVEQ,       0xF000, 0x7000, { 4, 4, 4}},
    {OPCODE_BCC,         0xF180, 0xF080, { 0, 0, 4}},
};

/* LINKER FUNCTION TO BE ABLE TO INITIALISE OPCODE FUNCTIONALITY ACROSS FILES */

void M68K_INIT_OPCODE()
{
    struct OPCODE* OPCODE_BASE;
    GENERATE_OPCODE(&OPCODE_BASE, *OPCODE_BASE->OPCODE_SIZE);
}

/* FINALLY, WE CAN BEGIN TO BUILD THE OPCODE TABLE BASED ON THE CORRESPONDENCE ESTABLISHED */
/* IN THE GENERATOR FUNCTION */

/* THIS DIFFERENCE BETWEEN THE TWO IS THAT THIS ONE ENCOMPASSES THE INSTRUCTION TYPES AND METHODS */
/* WHEREAS THE GENERATOR FOCUSSES MORESO ON THE INDEXXING OF SAID OPCODES */

void M68K_BUILD_OPCODE_TABLE(void)
{
    OPCODE_MASK_MODE MASK_MODE;
    struct OPCODE* OPCODE_HANDLER;
    struct CPU_68K* CPU_68K;
    int INDEX;

    /* FOR EVERY SUBSEQUENT MASK MODE OF THE OPCODE TABLE */
    /* SORT BETWEEN THE RESPECTIVE ELEMENTS AND DISCERN THEIR CORRESPONDENCE */
    /* IN RELATION TO WHICH INSTRUCTION IS BEING USED */

    /* THIS EMPOSES THE ASSUMPTION THAT THE OPCODE'S WILL BE ALLOCATED */
    /* TO A RESPECTIVE REGISTER TO GOVERN A SPECIFIC AREA */

    switch (MASK_MODE)
    {
        case OPCODE_MASK_ILLEGAL:
            if(INDEX = 0 && INDEX < M68K_MAX_INSTR_LENGTH)
            {
                memset(OPCODE_HANDLER->HANDLER, 0xFF, 0);
                CPU_68K->INSTRUCTION_CYCLES[INDEX][OPCODE_HANDLER->PATTERN];
            }
            break;

        case OPCODE_MASK_LOG_BIT:
            for (INDEX = 0; INDEX < 8; INDEX++)
            {
                OPCODE_HANDLER->INSTRUCTION = OPCODE_HANDLER->HANDLER;

                if(!OPCODE_HANDLER->INSTRUCTION && M68K_MAX_INSTR_LENGTH == 0)
                {
                    CPU_68K->INSTRUCTION_CYCLES[0] = (CPU_68K->INSTRUCTION_CYCLES[1], OPCODE_HANDLER->INSTRUCTION + INDEX);
                }
            }

            break;

        case OPCODE_MASK_LOG_OR:
            for (INDEX = 0; INDEX < 0xF; INDEX++)
            {
                OPCODE_HANDLER->INSTRUCTION = OPCODE_HANDLER->HANDLER;
                CPU_68K->INSTRUCTION_CYCLES[INDEX] = OPCODE_HANDLER->PATTERN[INDEX] | CPU_68K->INSTRUCTION_CYCLES[INDEX];
            }
            
        
    default:
        for (INDEX = 0; INDEX < M68K_MAX_INSTR_LENGTH; INDEX++)
        {
            return;
        }
        break;
    }
    
}
