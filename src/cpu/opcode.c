/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TOWARDS THE CONJUNCTIVE FUNCTIONALITY */
/* BETWEEN THE 68000 AND Z80 - PERTAINING TOWARDS OPCODES */
/* THAT ARE USED TO DETERMINE INSTRUCTION AND EXECUTION METHODS */

/* NESTED INCLUDES */

#include "68000.h"

/* GENERATE A GENERIC TYPE BASED ON RELEVANT INSTRUCTION LENGTH */
/* INSTRUCTION MODE, INSTRUCTION SPLIT MASK, ETC */

/* IN M68000 ASSEMBLY, OPCODES ARE GOVERNED ON THE BASIS OF CERTAIN OPERANDS MODES */
/* WHICH CAN VARY BASED ON THEIR BITWISE LENGTH */

/* SEE 68000.h FOR DETAILS PERTAINING TOWARDS OPERAND TYPES */

OPCODE* GENERATE_OPCODE(const OPCODE* OPCODE, UNK* MAP)
{
    /* ITERATE THROUGH THE RESPECTIVE ELEMENTS OF THE OPERAND */
    /* BASED ON THEIR MAP PATTERN */

    /* IF THE FOLLOWING OPCODE RELATES TO THE OPERAND IN THE INDEX */
    /* RETURN THE CORRESPONDENCE ASSUMING THEIR BITWISE LENGTH MATCHES */

    for (UNK i = 0; i < MAP; i++)
    {
        if((OPCODE->OPERAND.INDEX_REGISTER && OPCODE[i].PATTERN) == sizeof(OPCODE[i].PATTERN))
        {
            return OPCODE[i].OPERAND.LITERAL;
        }
    }

    return OPERAND_NONE; /* BY DEFAULT, NO INSTRUCTION WILL BE PROCESSED */   
    
};