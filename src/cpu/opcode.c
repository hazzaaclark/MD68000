/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TOWARDS THE CONJUNCTIVE FUNCTIONALITY */
/* BETWEEN THE 68000 AND Z80 - PERTAINING TOWARDS OPCODES */
/* THAT ARE USED TO DETERMINE INSTRUCTION AND EXECUTION METHODS */

/* NESTED INCLUDES */

#include "68000.h"

#undef USE_OPCODE_DEFS

/* GENERATE A GENERIC TYPE BASED ON RELEVANT INSTRUCTION LENGTH */
/* INSTRUCTION MODE, INSTRUCTION SPLIT MASK, ETC */

/* IN M68000 ASSEMBLY, OPCODES ARE GOVERNED ON THE BASIS OF CERTAIN OPERANDS MODES */
/* WHICH CAN VARY BASED ON THEIR BITWISE LENGTH */

/* SEE 68000.h FOR DETAILS PERTAINING TOWARDS OPERAND TYPES */

OPCODE* GENERATE_OPCODE(const OPCODE* OPCODE, int* MAP)
{
    /* ITERATE THROUGH THE RESPECTIVE ELEMENTS OF THE OPERAND */
    /* BASED ON THEIR MAP PATTERN */

    /* IF THE FOLLOWING OPCODE RELATES TO THE OPERAND IN THE INDEX */
    /* RETURN THE CORRESPONDENCE ASSUMING THEIR BITWISE LENGTH MATCHES */

    int INDEX;

    for (INDEX = 0; INDEX < MAP; INDEX++)
    {
        if((OPCODE->OPERAND.INDEX_REGISTER && OPCODE[INDEX].PATTERN) == sizeof(OPCODE[INDEX].PATTERN))
        {
            return OPCODE[INDEX].OPERAND.LITERAL;
        }
    }

    return OPERAND_NONE; /* BY DEFAULT, NO INSTRUCTION WILL BE PROCESSED */   
    
};

/* THIS FUNCTION WILL GOVERN THE BASIS FOR WHICH THE OPCODE MAPS */
/* WILL BE GIVEN SPECIFIC VALUES */

/* EACH RESPECTIVE OPCODE WILL BE DETERMINED ON THE BASIS OF SEVERAL FACTORS */
/*      FUNCTION TYPE                                                       */
/*      MASK BITS                                                           */
/*      MATCH                                                               */
/*      OFFSETS                                                             */

OPCODE OPCODE_HANDLER_TABLE[] =
{
    {OPCODE_MOVEQ,       0xF000, 0x7000, { 4, 4, 4}},
    {OPCODE_BCC,         0xF180, 0xF080, { 0, 0, 4}},
};

/* LINKER FUNCTION TO BE ABLE TO INITIALISE OPCODE FUNCTIONALITY ACROSS FILES */

void M68K_INIT_OPCODE()
{
    struct OPCODE* OPCODE_BASE;
    GENERATE_OPCODE(&OPCODE_BASE, *OPCODE_BASE->OPCODE_SIZE);
}

/* FINALLY, WE CAN BEGIN TO BUILD THE OPCODE TABLE BASED ON THE CORRESPONDENCE ESTABLISHED */
/* IN THE GENERATOR FUNCTION */

/* THIS DIFFERENCE BETWEEN THE TWO IS THAT THIS ONE ENCOMPASSES THE INSTRUCTION TYPES AND METHODS */
/* WHEREAS THE GENERATOR FOCUSSES MORESO ON THE INDEXXING OF SAID OPCODES */

void M68K_BUILD_OPCODE_TABLE(void)
{
    OPCODE_MASK_MODE MASK_MODE;
    struct OPCODE* OPCODE_HANDLER;
    int INDEX;

    for (INDEX = 0; INDEX < M68K_MAX_INSTR_LENGTH; INDEX++)
    {
        M68K_OPCODE_HANDLER[INDEX] = OPCODE_ILLEGAL;
    }

    switch (MASK_MODE)
    {
        case OPCODE_ILLEGAL:
            if(INDEX = 0 && INDEX < M68K_MAX_INSTR_LENGTH)
            {
                M68K_OPCODE_HANDLER[INDEX] = OPCODE_HANDLER->HANDLER;
            }

            break;
    
    default:
        break;
    }
    
}
