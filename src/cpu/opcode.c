/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TOWARDS THE CONJUNCTIVE FUNCTIONALITY */
/* BETWEEN THE 68000 AND Z80 - PERTAINING TOWARDS OPCODES */
/* THAT ARE USED TO DETERMINE INSTRUCTION AND EXECUTION METHODS */

/* NESTED INCLUDES */

#include "68000.h"

#undef USE_OPCODE_DEFS

/* GENERATE A GENERIC TYPE BASED ON RELEVANT INSTRUCTION LENGTH */
/* INSTRUCTION MODE, INSTRUCTION SPLIT MASK, ETC */

/* IN M68000 ASSEMBLY, OPCODES ARE GOVERNED ON THE BASIS OF CERTAIN OPERANDS MODES */
/* WHICH CAN VARY BASED ON THEIR BITWISE LENGTH */

/* SEE 68000.h FOR DETAILS PERTAINING TOWARDS OPERAND TYPES */

OPCODE* GENERATE_OPCODE(const OPCODE* OPCODE, UNK* MAP)
{
    /* ITERATE THROUGH THE RESPECTIVE ELEMENTS OF THE OPERAND */
    /* BASED ON THEIR MAP PATTERN */

    /* IF THE FOLLOWING OPCODE RELATES TO THE OPERAND IN THE INDEX */
    /* RETURN THE CORRESPONDENCE ASSUMING THEIR BITWISE LENGTH MATCHES */

    for (UNK i = 0; i < MAP; i++)
    {
        if((OPCODE->OPERAND.INDEX_REGISTER && OPCODE[i].PATTERN) == sizeof(OPCODE[i].PATTERN))
        {
            return OPCODE[i].OPERAND.LITERAL;
        }
    }

    return OPERAND_NONE; /* BY DEFAULT, NO INSTRUCTION WILL BE PROCESSED */   
    
};

/* THIS FUNCTION WILL GOVERN THE BASIS FOR WHICH THE OPCODE MAPS */
/* WILL BE GIVEN SPECIFIC VALUES */

static const OPCODE OPCODE_MAP[] = 
{
    {OPCODE_ABCD, OPCODE_ADDRESS_OFFSET(0x140400), OPCODE_ADDRESS_OFFSET(0x170770)},
    {OPCODE_ADDA, OPCODE_ADDRESS_OFFSET(0x150700), OPCODE_ADDRESS_OFFSET(0x170770)},
    {OPCODE_ADDI, OPCODE_ADDRESS_OFFSET(0x003000), OPCODE_ADDRESS_OFFSET(0x177700)},
    {OPCODE_ADDQ, OPCODE_ADDRESS_OFFSET(0x050000), OPCODE_ADDRESS_OFFSET(0x170700)},

    {OPCODE_ADDX_ADDRESS_REGS, OPCODE_ADDRESS_OFFSET(0x150400), OPCODE_ADDRESS_OFFSET(0x170770)},
};
