/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TOWARDS THE MAIN FUNCTIONALITY OF THE CONSOLE */

/* NESTED INCLUDES */

#include "md.h"
#include "68000.h"
#include "common.h"

#ifdef USE_MD

/* INITIALISE THE CONSOLE THROUGH THE PRE-REQUISTIES */
/* ESTABLISHED IN THE CORRESPONDING HEADER FILES */

/* THIS FUNCTION ENCOMPASSES THE FUNCTIONALITY OF ENABLING */
/* THE MEMORY MANAGEMENT UNIT FOR ALLOWING THE CONSOLE TO BEGIN */
/* IT'S INITIAL COMMUNICATIONS BETWEEN M68K AND Z80 ON STARTUP */

STATIC
void MD_INIT(void)
{
    struct MD* MD_CONSOLE;
    struct CPU_68K* CPU_68K;

    if((MD_CONSOLE->SYSTEM_TYPE == SYSTEM_MD))
    {
        M68K_INIT();
        CPU_68K->ADDRESS_RT_CHECK = (U8*)malloc(sizeof(CPU_68K->ERROR_ADDRESS));

        /* ASSUMING THAT THE ABOVE COROUTINE HAVE BEEN ESTABLISHED */
        /* THE MEMORY MAP WILL NOW BE INITIALISED */

        /* THIS FUNCTIONALITY IS SIMILAR TO THE WAY IN WHICH IT WORKS */
        /* ON REAL HARDWARE WITH THE WAY IN WHICH THE VECTOR TABLE INITIALISES */ 

        for (int i = 0; i < 0xFF; i++)
        {
            CPU_68K->MEMORY_MAP[i].BASE = (U8*)malloc(sizeof(MD_CONSOLE->BOOT_RAM));
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_8 = M68K_READ_8(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_8 = M68K_WRITE_8(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_16 = M68K_READ_16(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_16 = M68K_WRITE_16(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);

            CPU_68K->Z80_MEM[i].READ = Z80_READ(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->Z80_MEM[i].WRITE = Z80_WRITE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
        }

        /* VDP ENTRY POINTS */

        for (int i = 0xC; i < 0xFF; i++)
        {
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_8 = VDP_READ_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_8 = VDP_WRITE_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_16 = VDP_READ_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_16 = VDP_WRITE_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
        }

        /* EVALUABLE RAM HEADER */

        for (int i = 0; i < 0xc100; i++)
        {
            CPU_68K->MEMORY_MAP[i].BASE = (U8*)malloc(MD_CONSOLE->BOOT_RAM);
            MD_CONSOLE->ZBANK[i] = NULL;
        }

        /* IO CONTROL REGISTERS */

        for (int i = 0; i < 0xA100; i++)
        {
            CPU_68K->MEMORY_MAP[0xA1].MEMORY_READ_8 = CTRL_READ_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[0xA1].MEMORY_WRITE_8 = CTRL_WRITE_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
             CPU_68K->MEMORY_MAP[0xA1].MEMORY_READ_8 = CTRL_READ_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[0xA1].MEMORY_WRITE_8 = CTRL_WRITE_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);

        }
        
        MD_CART_INIT();
    }
}

/* NOW COMES THE COROUTINE FOR RESETTING THE CONSOLE */
/* THIS WILL DETERMINE BY AN NUMERICAL VALUE TO DISCERN THE RESET TYPE */

/* WHEN IT COMES TO RESET METHODS ON THE MEGA DRIVE, ESPECIALLY IN THE HEADER */
/* OF THE MAIN ASSEMBLY FILE, IT INVOLVES THE MOVE INSTRUCTION OF THE VALUE FROM D7 */
/* INTO ONE OF THREE ADDRESSING MODES */

/* A1, A2 & A3 ENCOMPASS THE INITIAL STEPS FOR HARDWARE COROUTINE CHECKS */
/* AS THESE ARE THE MAIN 3 REGISTERS THAT COMMUNICATE WITH THE BUS */

/* D7 ACTS AS THE STACK POINTER TO DETERMINE WHERE THE DATA SHOULD GO TOWARDS */

/* SEE 68K INSTRUCTION REF. https://md.railgun.works/index.php?title=68k_Instruction_Reference */

STATIC
void MD_RESET(void)
{
    struct MD* MD_CONSOLE;
    struct CPU_68K* CPU_68K;
    int RESET_MODE;
    MD_RESET_MODE MODE;

    switch (RESET_MODE)
    {
        /* SOFT RESET TYPICALLY ENTAILS A SOFTWARE RESET */
        /* A SIMPLE CHECK SHOULD BE FINE */ 

        case MODE_SOFT:
            if(RESET_MODE == NULL)
                break;

        /* HARD RESET ENVOKES THAT ALL ASPECTS OF THE CONSOLE NEED TO BE */
        /* RESET INDICATIVE OF THE PRESSING OF THE RESET BUTTON */

        /* IN ASSEMBLY, THIS WOULD TYPICALLY ENTAIL USING THE RESET FLAG */
        /* TO RESET CPU EXECUTION BASED ON THEIR REGISTER COUNT */

        case MODE_HARD:
            CPU_68K->INSTRUCTION_CYCLES = sizeof(CPU_68K->INSTRUCTION_CYCLES / 7);
            CPU_68K->Z80_MEM->CYCLES = sizeof(CPU_68K->INSTRUCTION_CYCLES / 15);
    
    /* THE DEFAULT IS TO EVALUATE THE SIZE OF THE RAM */
    /* SUCH THAT EXECUTUON CAN START ALL OVER AGAIN */ 

    default:
        memset(MD_CONSOLE->BOOT_RAM, 0x00, sizeof(MD_CONSOLE->BOOT_RAM));
        memset(MD_CONSOLE->ZRAM, 0x00, sizeof(MD_CONSOLE->ZRAM));
        break;
    }
}

#endif
