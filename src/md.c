/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TOWARDS THE MAIN FUNCTIONALITY OF THE CONSOLE */

/* NESTED INCLUDES */

#include "md.h"
#include "68000.h"
#include "common.h"

#ifdef USE_MD

/* INITIALISE THE CONSOLE THROUGH THE PRE-REQUISTIES */
/* ESTABLISHED IN THE CORRESPONDING HEADER FILES */

/* THIS FUNCTION ENCOMPASSES THE FUNCTIONALITY OF ENABLING */
/* THE MEMORY MANAGEMENT UNIT FOR ALLOWING THE CONSOLE TO BEGIN */
/* IT'S INITIAL COMMUNICATIONS BETWEEN M68K AND Z80 ON STARTUP */

void MD_INIT(void)
{
    struct MD* MD_CONSOLE;
    struct CPU_68K* CPU_68K;

    if((MD_CONSOLE->SYSTEM_TYPE == SYSTEM_MD))
    {
        M68K_INIT();
        CPU_68K->ADDRESS_RT_CHECK = malloc(sizeof(CPU_68K->ERROR_ADDRESS));

        /* ASSUMING THAT THE ABOVE COROUTINE HAVE BEEN ESTABLISHED */
        /* THE MEMORY MAP WILL NOW BE INITIALISED */

        /* THIS FUNCTIONALITY IS SIMILAR TO THE WAY IN WHICH IT WORKS */
        /* ON REAL HARDWARE WITH THE WAY IN WHICH THE VECTOR TABLE INITIALISES */ 

        for (int i = 0; i < 0xFF; i++)
        {
            CPU_68K->MEMORY_MAP[i].BASE = malloc(sizeof(MD_CONSOLE->BOOT_RAM));
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_8 += M68K_READ_8(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_8 += M68K_WRITE_8(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_16 += M68K_READ_16(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_16 += M68K_WRITE_16(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);

            CPU_68K->Z80_MEM[i].READ += Z80_READ(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->Z80_MEM[i].WRITE += Z80_WRITE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
        }

        /* VDP ENTRY POINTS */

        for (int i = 0xC; i < 0xFF; i++)
        {
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_8 += VDP_READ_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_8 += VDP_WRITE_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
            CPU_68K->MEMORY_MAP[i].MEMORY_READ_16 += VDP_READ_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[i].MEMORY_WRITE_16 += VDP_WRITE_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
        }

        /* EVALUABLE RAM HEADER */

        for (int i = 0; i < 0xc100; i++)
        {
            CPU_68K->MEMORY_MAP[i].BASE = (U8*)malloc(MD_CONSOLE->BOOT_RAM);
            MD_CONSOLE->ZBANK[i] = NULL;
        }

        /* IO CONTROL REGISTERS */

        for (int i = 0; i < 0xA100; i++)
        {
            CPU_68K->MEMORY_MAP[0xA1].MEMORY_READ_8 = CTRL_READ_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[0xA1].MEMORY_WRITE_8 = CTRL_WRITE_BYTE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
             CPU_68K->MEMORY_MAP[0xA1].MEMORY_READ_8 = CTRL_READ_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
            CPU_68K->MEMORY_MAP[0xA1].MEMORY_WRITE_8 = CTRL_WRITE_WORD(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);

        }
        
        MD_CART_INIT();
    }
}

/* NOW COMES THE COROUTINE FOR RESETTING THE CONSOLE */
/* THIS WILL DETERMINE BY AN NUMERICAL VALUE TO DISCERN THE RESET TYPE */

/* WHEN IT COMES TO RESET METHODS ON THE MEGA DRIVE, ESPECIALLY IN THE HEADER */
/* OF THE MAIN ASSEMBLY FILE, IT INVOLVES THE MOVE INSTRUCTION OF THE VALUE FROM D7 */
/* INTO ONE OF THREE ADDRESSING MODES */

/* A1, A2 & A3 ENCOMPASS THE INITIAL STEPS FOR HARDWARE COROUTINE CHECKS */
/* AS THESE ARE THE MAIN 3 REGISTERS THAT COMMUNICATE WITH THE BUS */

/* D7 ACTS AS THE STACK POINTER TO DETERMINE WHERE THE DATA SHOULD GO TOWARDS */

/* SEE 68K INSTRUCTION REF. https://md.railgun.works/index.php?title=68k_Instruction_Reference */

void MD_RESET(void)
{
    struct MD* MD_CONSOLE;
    struct CPU_68K* CPU_68K;
    int RESET_MODE;
    MD_RESET_MODE MODE;

    switch (MODE)
    {
        /* SOFT RESET EVOKES THE METHODS USED TO */
        /* RESET THE CONSOLE FROM A SOFTWARE */
        /* THIS WILL BE GOVERNED BY THE STACK POINTER */
        /* STORING THE LOCATION OF THE BOOT RAM CACHE */

        /* FROM THERE, BOOT BACK TO THE START OF THE PROGRAM EXECUTION */
        /* IN RELATION TO THE BOOT RAM GOVERNED BY IT'S DESIGNATED DATA REGISTER */

        case MODE_SOFT:
            CPU_68K->PC = MD_CONSOLE->BOOT_RAM;
            CPU_68K->STACK_POINTER = 0x2700;
            CPU_68K->REGISTER_BASE[7] = MD_CONSOLE->BOOT_RAM;
            break;

        /* HARD RESET ENVOKES THAT ALL ASPECTS OF THE CONSOLE NEED TO BE */
        /* RESET INDICATIVE OF THE PRESSING OF THE RESET BUTTON */

        /* IN ASSEMBLY, THIS WOULD TYPICALLY ENTAIL USING THE RESET FLAG */
        /* TO RESET CPU EXECUTION BASED ON THEIR REGISTER COUNT */

        /* THE DIFFERENCE BEING IS THAT WE EVOKE MEMSET TO ASSERT ALL VALUES */
        /* BACK TO DEFAULT */

        case MODE_HARD:
            CPU_68K->PC = MD_CONSOLE->BOOT_RAM;
            CPU_68K->STACK_POINTER = 0x2700;
            CPU_68K->REGISTER_BASE[7] = MD_CONSOLE->BOOT_RAM;
            memset(MD_CONSOLE->BOOT_RAM, 0x00, sizeof(MD_CONSOLE->BOOT_RAM));
            memset(MD_CONSOLE->ZRAM, 0x00, sizeof(MD_CONSOLE->ZRAM));
            break;

        default:
            free(&MD_CONSOLE->MD_CART);
            free(&CPU_68K->Z80_MEM);
            free(&CPU_68K);
    }
}

/* THE BANK SWITCH FUNCTIONS LOOKS INTO THE CORRESPODENCE STORED IN */
/* THE ZBUFFER TO DETERMINE THE OFFSET OF MEMORY ALLOCATIONS */

/* THIS WILL CHECK TO SEE IF THE BOOT ROM HAS BEEN LOADED AND IF SO */
/* MIMMICK THE FUNCTIONALITY OF THE JUMP COROUTINE TO INITIALISE THE START OF THE CART */

U32* MD_BANKSWITCH(unsigned int VALUE)
{
    static struct MD MD_CONSOLE;
    struct CPU_68K* CPU_68K;

    /* IS THE BOOT ROM INITIALISED? */

    switch (MD_CONSOLE.SYSTEM_BIOS)
    {

    case 0:
        CPU_68K->MEMORY_MAP[0].BASE = MD_CONSOLE.BOOT_ROM;

    /* IS THE ROM LOADED IN THE MEMORY MAP? */

    case 1:
        CPU_68K->MEMORY_MAP[0].BASE = MD_CONSOLE.MD_CART->ROM_BASE;
        break;
    
    default:
        if(MD_CONSOLE.SYSTEM_BIOS == SYSTEM_MD)
            return (&CPU_68K->MEMORY_MAP[0].BASE == MD_CONSOLE.MD_CART->ROM_BASE);
    }

    return ZBUFFER_MAX;
}

/* INITIALISE THE FUNCTIONALITY PERTAINING TOWARDS THE Z80 AS IT COMMUNICATES */
/* WITH THE CONSOLE */

/* THE FOLLOWING WILL ENCOMPASS ACCESS TO READ AND WRITE FROM THE 68K MEMORY MAP */
/* TO UPDATE IT'S STATUS IN RELATION TO THE COMMUNICATION WITH THE PC */

void MD_BUS_REQ(unsigned STATE, unsigned CYCLES)
{
    struct CPU_68K* CPU_68K;
    struct MD* MD_CONSOLE;
    assert(&STATE); /* EVALUATE THE INITIAL STATE */

    /* BEGIN BY SYNCHRONISING WITH THE 68K */
    /* THERE WILL BE A DIFFERENT FUNCTION IN PLACE BY IN THE MEANTIME */
    /* WE WILL EVALUATE IT'S PROBABLE MEMORY */

    if(MD_CONSOLE->ZSTATE == 1)
    {
        memset(&MD_CONSOLE, STATE, CYCLES);

        /* EVALUATE THE ACCESS BETWEEN THE 68K AND Z80 AFTER THE SYNC */

        CPU_68K->MEMORY_MAP[0xA0].MEMORY_READ_8 = Z80_READ(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
        CPU_68K->MEMORY_MAP[0xA0].MEMORY_WRITE_8 = Z80_WRITE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
        CPU_68K->MEMORY_MAP[0xA0].MEMORY_READ_16 = Z80_READ(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS);
        CPU_68K->MEMORY_MAP[0xA0].MEMORY_WRITE_16 = Z80_WRITE(CPU_68K->MEMORY_DATA, CPU_68K->MEMORY_ADDRESS, CPU_68K->MEMORY_POINTER);
    }

    STATE |= 2;
}

#endif
