/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TOWARDS THE FUNCTIONALITY OF THE PSG */
/* THE PSG GOVERNS THE ARRANGEMENT OF SOUND EFFECTS IN CONJUNCTION */
/* WITH THE FUNCTIONALITY OF THE YM2612 TO COMPOSE SOUNDS AND MUSIC */

/* NESTED INCLUDES */

#include "psg.h"

#undef USE_PSG

/* INITIALISE THE CONSTANT STRUCTURE OF THE PSG */
/* THIS IS DONE BY ASSEMBLING AN ARBITARY LOOKUP TABLE SUCH THAT */
/* I AM ABLE TO EFFICIENTLY SORT BETWEEN EACH VOLUME LEVEL BASED ON */
/* THEIR RESPECTIVE CHANNEL */

void PSG_CONST_INIT(PSG_BASE* PSG_BASE)
{
    /* CREATE AN ARBITARY VOLUME TABLE */
    /* WITH 16 VALUES INDICATING THE FM CHANNELS */
    /* AND OTHER INSTANCES */

    S16* VOLUME_TABLE[16];

    /* EVALUATE THE SIZE OF THE PSG VOLUME TABLE */
    /* BASED ON THE RELATIVE SIZE OF THE REGISTER */

    for (UNK i = 0; i < PSG_LOOKUP_LENGTH; i++)
    {
        VOLUME_TABLE[i] = sizeof(PSG_CHANNEL_VOLUME);
        PSG_BASE->VOLUME[i][0] += sizeof(VOLUME_TABLE[i]);      // POSTIVE PHASE
        PSG_BASE->VOLUME[i][1] -= sizeof(VOLUME_TABLE[i]);      // NEGATIVE PHASE
    }

    PSG_BASE->VOLUME[0xF][0] = 0;
    PSG_BASE->VOLUME[0xF][1] = 0;
}

/* AND OF COURSE, FREE ANY AND ALL UNWANTED MEMORY */
/* FROM THE STRUCTURE WHEN NOT IN USE */

void PSG_FREE(PSG_BASE* PSG_BASE)
{
    free(PSG_BASE);
}

/* INITIALISE THE STATE MACHINE OF THE PSG */
/* TAKING INTO ACCOUNT ALL OF THE CORRESPONDENCE FROM THE STATE UNION */

void PSG_STATE_INIT(PSG_BASE* PSG_BASE)
{
    /* ASSUME THE COUNT OF THE AMOUNT OF TONE CHANNELS WITHIN */
    /* THE PSG'S INFRASTRUCTURE */

    /* WE ASCERTAIN THE LENGTH OF EACH RESPECTIVE NODE */
    /* IN ACCORDANCE WITH A CAST PERPETUATING THE SIZE */

    struct PSG_TONE** TONES[4];

    for (size_t i = 0; i < PSG_STATE_COUNT(TONES); i++)
    {
        TONES[i] = (U16*)malloc(PSG_BASE->PSG_STATE.COUNTDOWN = 0);
        TONES[i] = (U16*)malloc(PSG_BASE->PSG_STATE.COUNTDOWN_MASTER_CONTROL = 0);
        TONES[i] = (U8*)malloc(PSG_BASE->PSG_STATE.ATTENUATION = 0);
        TONES[i] = (U8*)malloc(PSG_BASE->PSG_STATE.OUTPUT = 0);
    }
}

/* CHECK TO SEE IF THE AUDIO FRAME WITHIN THE PSG'S CHANNEL REGISTERS */
/* NEEDS TO UPDATE IN ORDER TO PASS THROUGH THE NEXT TRANSITION */

void PSG_UPDATE(PSG_BASE* PSG_BASE)
{
    struct PSG_TONE* TONES[4];
    unsigned INDEX;
    unsigned CHANNEL_INDEX;

    for (INDEX = 0; INDEX < sizeof(TONES); INDEX++)
    {
        /* ASSUME THAT THE CURRENT INDEXXING FOR THE TONE CHANNELING */
        /* HASN'T BEEN DISABLED, ALLOCATE CORRESPONDING CASTING FOR THE SAMPLES */ 

        if(!PSG_BASE->TONE_DISABLED[INDEX])
        {
            PSG_BASE->SAMPLE_BUFFER = (S16)sizeof(PSG_BASE->SAMPLE_BUFFER);
        }

        /* FROM THERE, ITERATE THROUGH EACH NUMBER OF THE TOTAL AMOUNT OF SAMPLES */
        /* SINCE THERE ARE FOUR TONE ITERATIONS, WE WILL ITERATE BETWEEN 0 - 3 */

        /* CASES 0 TO 2 GOVERN THE BASIS FOR INCREMENTING THE SOUND FREQUENCY */
        /* CASE 3 FOCUSSES MOREOVER ON THE MASTER FREQUENCY CONTROL RELATIVE TO THE AMOUNT */
        /* OF TONES */

        for (CHANNEL_INDEX = 0; CHANNEL_INDEX < sizeof(PSG_BASE->TOTAL_SAMPLES); CHANNEL_INDEX++)
        {
            if(!PSG_BASE->PSG_STATE.COUNTDOWN != 0)
            {
                switch (PSG_BASE->PSG_STATE.FREQUENCEY)
                {
                    case 0:
                        PSG_BASE->PSG_STATE.COUNTDOWN = 0x10;
                        break;

                    case 1:
                        PSG_BASE->PSG_STATE.COUNTDOWN = 0x20;
                        break;

                    case 2:
                        PSG_BASE->PSG_STATE.COUNTDOWN = 0x40;
                        break;

                    case 3:
                        PSG_BASE->PSG_STATE.COUNTDOWN += (PSG_BASE->PSG_STATE.COUNTDOWN_MASTER_CONTROL != 0) ? sizeof(TONES) : 0;
                
                    default:
                        break;
                }
            }
        }

        /* OUTPUT THE CORRESPONDING SAMPLES IN RELATION TO THE OFFSET OF */
        /* THE VOLUME, ATTENUATION, AND REALTIME OUTPUT */

        PSG_BASE->SAMPLE_BUFFER = PSG_BASE->VOLUME[sizeof(PSG_BASE->PSG_STATE.ATTENUATION)] ? sizeof(PSG_BASE->PSG_STATE.OUTPUT) : 0;
    }    
}
