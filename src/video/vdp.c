/* Copyright(C) 2023 Harry Clark * /

/* SEGA Mega Drive Emulator */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONALITY OF THE VIDEO DISPLAY PORT OF THE MEGA DRIVE */
/* TAKING INTO ACCOUNT THE INTRICACIES OF THE SYSTEM THROUGH VARIOUS PIECES OF DOCUMENTATION */

/* DOCUMENTATION INCLUDES: */

/* https://wiki.megadrive.org/index.php?title=VDP */
/* http://md.railgun.works/index.php?title=VDP */
 
/* NESTED INCLUDES */

#include "68000.h"
#include "vdp.h"
#include "common.h"

/* CREATE AN INSTANCE OF THE VDP BY ALLOCING THE SCREEN BUFFER */
/* THIS WILL CREATE VIRTUAL MEMORY ASSOCIATED WITH THE BYTEWISE SIZE */
/* OF THE UNIT */

#undef USE_VDP

/* INITIALISE THE CORRESPONDING SIZE OF THE SPRITE TABLE */
/* THIS IS DONE AT RUNTIME TO EVALUATE HOW THE VDP WILL RENDER ON STARTUP */

STATIC
void VDP_CONST_INIT(struct VDP* VDP, struct VDP_STATE* STATE, U16 PIXEL_LOOKUP[])
{
	for (int PIXEL_HIGH = 0; PIXEL_HIGH < sizeof(VDP_SPRITE_LOOKUP); PIXEL_HIGH++)
	{
		for (int PIXEL_LOW = 0; PIXEL_LOW < sizeof(VDP_SPRITE_LOOKUP); PIXEL_LOW++)
		{
			// INITIALISE THE SIZE OF THE PIXEL OUTPUT IN RELATION TO THE LOOKUP TABLE

			STATE->PIXEL_OUTPUT += 1, sizeof(STATE->PIXEL_OUTPUT += 1, sizeof(STATE->DRAW_PIXEL ? STATE->NEW_PIXEL : STATE->OLD_PIXEL)); 
			STATE->PIXEL_OUTPUT |= STATE->PIXEL_NO_SHADOW ? STATE->PIXEL_NO_SHADOW_MASK : 0;

			// DYNAMICALLY ALLOCATE THE SPRITE LOOKUP TABLE 
			// IN ACCORDANCE WITH THE CORRESPONDING PIXEL CONSTANTS

			malloc(sizeof(VDP_SPRITE_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH], PIXEL_LOOKUP[PIXEL_LOW] += STATE->PIXEL_OUTPUT));
			malloc(sizeof(VDP_SPRITE_DETAIL_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH], PIXEL_LOOKUP[PIXEL_LOW] += STATE->PIXEL_OUTPUT));
		}
	}
}

/* INITIALISE THE CORRESPONDING VALUES TOWARDS THE STRUCTURED VARIABLES */

STATIC
void VDP_STATE_INIT(struct VDP_STATE* STATE)
{
	STATE->ACCESS_MODE.WRITE_PENDING = false;
	STATE->ACCESS_MODE.BUFFER = VDP_ACCESS_VRAM;
	STATE->ACCESS_MODE.READ_MODE = false;
	STATE->ACCESS_MODE.INDEXING = 0;
	STATE->ACCESS_MODE.INCREMENT = 0;

	STATE->DMA.ENABLED = false;
	STATE->DMA.PENDING = false;
	STATE->DMA.ADDRESS_MODE_HIGH = 0;
	STATE->DMA.ADDRESS_MODE_LOW = 0;

	STATE->PLANE_A_ADDRESS = 0;
	STATE->PLANE_B_ADDRESS = 0;
	STATE->WINDOW_ADDRESS = 0;
	STATE->SPRITE_TABLE = 0;
	STATE->HSCROLL_ADDRESS = 0;
	STATE->DISPLAY_ENABLED = false;
	STATE->VERTICAL_PLANE_ENABLED = false;
	STATE->HORI_PLANE_ENABLED = false;
	STATE->PLANE_WIDTH = 32;
	STATE->PLANE_HEIGHT = 32;
	STATE->PLANE_WIDTH_BITMASK = STATE->PLANE_WIDTH - 1;
	STATE->PLANE_HEIGHT_BITMASK = STATE->PLANE_HEIGHT - 1;

	STATE->H40_ENABLED = false;
	STATE->V30_ENABLED = false;
	STATE->SHADOW_ENABLED = false;
	STATE->SUPER_SAMPLING = false;

	STATE->BG_COLOUR = 0;
	STATE->HORI_INTERVAL = 0;
	STATE->VBLANK = 0;

	STATE->HSCROLL_MODE = VDP_HSCROLL_MODE_FULL;
	STATE->VSCROLL_MODE = VDP_VSCROLL_MODE_FULL;
}

/* RENDER THE TILESET BASED ON THE PLANE WIDTH AND HEIGHT */
/* THIS WILL TAKE INTO ACCOUNT THE METADATA NEEDED TO READ AND WRTIE TO */
/* TO THE RESPECTIVE PLANE ADDRESS */

STATIC
void VDP_RENDER_TILE(struct VDP* VDP, struct VDP_STATE* VDP_STATE)
{
	struct VDP_TILE* TILE;
	U16 TITLE_METADATA = VRAM_READ_WORD(VDP_STATE, VDP_STATE->PLANE_A_ADDRESS + (TILE->TILE_Y * VDP_STATE->PLANE_WIDTH + TILE->TILE_X) * 2);


}
