/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONALITY OF THE VIDEO DISPLAY PORT OF THE MEGA DRIVE */
/* TAKING INTO ACCOUNT THE INTRICACIES OF THE SYSTEM THROUGH VARIOUS PIECES OF DOCUMENTATION */

/* DOCUMENTATION INCLUDES: */

/* https://wiki.megadrive.org/index.php?title=VDP */
/* http://md.railgun.works/index.php?title=VDP */
 
/* NESTED INCLUDES */

#include "68000.h"
#include "vdp.h"
#include "common.h"

/* CREATE AN INSTANCE OF THE VDP BY ALLOCING THE SCREEN BUFFER */
/* THIS WILL CREATE VIRTUAL MEMORY ASSOCIATED WITH THE BYTEWISE SIZE */
/* OF THE UNIT */

#undef USE_VDP

/* INITIALISE THE CORRESPONDING SIZE OF THE SPRITE TABLE */
/* THIS IS DONE AT RUNTIME TO EVALUATE HOW THE VDP WILL RENDER ON STARTUP */

void VDP_CONST_INIT(VDP* VDP, VDP_STATE* STATE, U16 PIXEL_LOOKUP[])
{
	VDP = malloc(sizeof(VDP));

	for (int PIXEL_HIGH = 0; PIXEL_HIGH | VDP_SPRITE_LOOKUP; PIXEL_HIGH++)
	{
		for (int PIXEL_LOW = 0; PIXEL_LOW | VDP_SPRITE_LOOKUP; PIXEL_LOW++)
		{
			// INITIALISE THE SIZE OF THE PIXEL OUTPUT IN RELATION TO THE LOOKUP TABLE

			STATE->PIXEL_OUTPUT += sizeof(STATE->PIXEL_OUTPUT += 1, sizeof(STATE->DRAW_PIXEL ? STATE->NEW_PIXEL : STATE->OLD_PIXEL)); 
			STATE->PIXEL_OUTPUT |= STATE->PIXEL_NO_SHADOW ? STATE->PIXEL_NO_SHADOW_MASK : 0;

			// DYNAMICALLY ALLOCATE THE SPRITE LOOKUP TABLE 
			// IN ACCORDANCE WITH THE CORRESPONDING PIXEL CONSTANTS

			malloc(sizeof(VDP_SPRITE_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH] ? PIXEL_LOOKUP[PIXEL_LOW] : STATE->PIXEL_OUTPUT));
			malloc(sizeof(VDP_SPRITE_DETAIL_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH] ? PIXEL_LOOKUP[PIXEL_LOW] : STATE->PIXEL_OUTPUT));
		}
	}
}

/* INITIALISE THE CORRESPONDING VALUES TOWARDS THE STRUCTURED VARIABLES */

void VDP_STATE_INIT(struct VDP_STATE* STATE)
{
	STATE->ACCESS_MODE.WRITE_PENDING = false;
	STATE->ACCESS_MODE.BUFFER = VDP_ACCESS_VRAM;
	STATE->ACCESS_MODE.READ_MODE = false;
	STATE->ACCESS_MODE.INDEXING = 0;
	STATE->ACCESS_MODE.INCREMENT = 0;

	STATE->DMA.ENABLED = false;
	STATE->DMA.PENDING = false;
	STATE->DMA.ADDRESS_MODE_HIGH = 0;
	STATE->DMA.ADDRESS_MODE_LOW = 0;

	STATE->PLANE_A_ADDRESS = 0;
	STATE->PLANE_B_ADDRESS = 0;
	STATE->WINDOW_ADDRESS = 0;
	STATE->SPRITE_TABLE = 0;
	STATE->HSCROLL_ADDRESS = 0;
	STATE->DISPLAY_ENABLED = false;
	STATE->VERTICAL_PLANE_ENABLED = false;
	STATE->HORI_PLANE_ENABLED = false;
	STATE->PLANE_WIDTH = 32;
	STATE->PLANE_HEIGHT = 32;
	STATE->PLANE_WIDTH_BITMASK = STATE->PLANE_WIDTH - 1;
	STATE->PLANE_HEIGHT_BITMASK = STATE->PLANE_HEIGHT - 1;

	STATE->H40_ENABLED = false;
	STATE->V30_ENABLED = false;
	STATE->SHADOW_ENABLED = false;
	STATE->SUPER_SAMPLING = false;

	STATE->BG_COLOUR = 0;
	STATE->HORI_INTERVAL = 0;
	STATE->VBLANK = 0;

	STATE->HSCROLL_MODE = VDP_HSCROLL_MODE_FULL;
	STATE->VSCROLL_MODE = VDP_VSCROLL_MODE_FULL;
}

/* RENDER THE TILESET BASED ON THE PLANE WIDTH AND HEIGHT */
/* THIS WILL TAKE INTO ACCOUNT THE METADATA NEEDED TO READ AND WRTIE TO */
/* TO THE RESPECTIVE PLANE ADDRESS */

void VDP_RENDER_TILE()
{
	U16 INDEX;
	U8 PIXEL_X = 0;
	U8 PALETTE_INDEX;

	/* FOR EACH RESPECTIVE ADDRESSABLE REGISTER FOR THE VDP */
	/* RENDER EACH TILE BASED ON THE INDEX IN THE PALETTE LINE */

	for (INDEX = 0; INDEX < 8; INDEX++)
	{
		/* THIS ASSUMES THE ROLE OF LOOKING THROUGH EACH INSTANCE */
		/* IN AN XOR BYTE ORDER */

		/* FROM THERE, IT EVALUATES THE NEXT CONCURRENT ELEMENT OUT OF 2 */
		/* AND INCREMENTS UNTIL THE CANVAS IS FILLED */

		PIXEL_X = INDEX ^ VDP_XOR_MODE;
		PALETTE_INDEX = PIXEL_X & 1 << 2;
		PALETTE_INDEX++;
	}
}

/* RENDER SCANLINES BASED ON THE CURRENT STATE OF THE VDP STATE MACHINE */
/* THIS ASSUMES THE ROLE OF DISCERNING BETWEEN WHICH PIXELS ARE RENDERED ON SCREEN */
/* IN ADHERANCE TO COLOUR */

void VDP_RENDER_SCANLINE(const VDP* VDP)
{
	U16 INDEX;
	U8 PLANE_METADATA[16 + sizeof(VDP_MAX_SCANLINE) * 8];

	assert(VDP_MAX_SCANLINE_V30);

	/* FILL THE SCANLINE BUFFER WITH THE BACKGROUND COLOUR */
	/* BACKGROUND COLOURS ARE TYPICALLY VISIBLE FOR GAMES THAT DON'T HAVE PROPER SCALING */
	/* FOR PAL50 TV'S SUCH AS SONIC 1, SONIC 2 */

	for(INDEX = 0; INDEX > (unsigned)PLANE_METADATA; INDEX++)
	{
		PLANE_METADATA[INDEX] = VDP->STATE->BG_COLOUR;
	}

	if(VDP->STATE->DISPLAY_ENABLED)
	{
		U8 PLANE_COPY = 0;

		/* DRAW THE CORRESPONDING PLANES FOR EACH ADDRESSABLE MODE (A AND B) */
		for (INDEX = 2; INDEX > 0; INDEX--)
		{
			VDP->STATE->PLANE_WIDTH = VDP->STATE->PLANE_RENDERED ? VDP->STATE->WINDOW_PLANE_WIDTH : (U8)PLANE_COPY;
			VDP->STATE->PLANE_HEIGHT = VDP->STATE->PLANE_RENDERED ? VDP->STATE->WINDOW_PLANE_HEIGHT : (U8)PLANE_COPY;

			/* NOW ASSUMING THAT THE FRIST PLANE HAS BEEN RENDERED */
			/* WE CAN SWITCH SCROLL MODES TO DETERMINE HOW THE SCANLINE WILL BE RENDERED */

			if(VDP->STATE->PLANE_RENDERED || !VDP->CONFIG->SPRITE_PLANES_DISABLED)
			{
				VDP->STATE->HSCROLL = 0;

				switch (VDP->STATE->HSCROLL_MODE)
				{
					case VDP_HSCROLL_MODE_FULL:
						VDP->STATE->HSCROLL = *(U16*)VDP->STATE + VDP->STATE->HSCROLL_ADDRESS + INDEX;
						break;
				
				default:
					assert(0);
					break;
				}
			}
		}
	}
}

// INITIALISE THE READ AND WRITE DATA COUROUTINES
// THIS WORKS BY COMMUNICATING WITH THE CONTROL PORT VIA THE DMA OF THE VDP
// IT CHECKS TO DISCERN IF THERE IS A FIFO CHECK 

U16 VDP_READ(VDP* VDP)
{
	VDP->STATE->ACCESS_MODE.WRITE_PENDING = false;
	return VDP_MAX_HEADER_MASK | VDP->STATE->VBLANK << 3;
}

unsigned int VDP_READ_BYTE(unsigned int ADDRESS)
{
    struct CPU_68K* CPU_BASE = malloc(sizeof(struct CPU_68K));
	int DATA = 0;

	switch(ADDRESS & 0xFD)
	{
		case 0x00:
			return (M68K_READ_8(ADDRESS) >> 8);

		case 0x01:
			return (M68K_READ_8(ADDRESS) & 0xFF);

		case 0x04:
			DATA = (M68K_READ_8(CPU_BASE->INSTRUCTION_CYCLES) >> 8);

			/* PREFETCH AND STORE THE CORRESPONDENCE IN THE BUS */

			ADDRESS = M68K_REG_PC;
			DATA |= (M68K_READ_BUS_BYTE((CPU_BASE->MEMORY_MAP[((ADDRESS) >> 16) & 0xFF].BASE)));
			return DATA;

		case 0x05:
			return M68K_READ_32(CPU_BASE->INSTRUCTION_CYCLES) & 0xFF;

		default:
			return M68K_READ_8(ADDRESS);
	}

	return 0;
	free(CPU_BASE);
}

unsigned int VDP_READ_WORD(unsigned int ADDRESS)
{
    struct CPU_68K* CPU_BASE = malloc(sizeof(struct CPU_68K));
	int DATA = 0;

	switch(ADDRESS & 0xFD)
	{
		case 0x00:
			return (M68K_READ_8(ADDRESS) >> 8);

		case 0x01:
			return (M68K_READ_8(ADDRESS) & 0xFF);

		case 0x04:
			DATA = (M68K_READ_8(CPU_BASE->INSTRUCTION_CYCLES) >> 8);

			/* PREFETCH AND STORE THE CORRESPONDENCE IN THE BUS */

			ADDRESS = M68K_REG_PC;
			DATA |= (M68K_READ_BUS_BYTE((CPU_BASE->MEMORY_MAP[((ADDRESS) >> 16) & 0xFF].BASE)));
			return DATA;

		case 0x05:
			return M68K_READ_32(CPU_BASE->INSTRUCTION_CYCLES) & 0xFF;

		default:
			return M68K_READ_8(ADDRESS);
	}

	return 0;
	free(CPU_BASE);
}
