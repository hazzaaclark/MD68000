/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONALITY OF THE VIDEO DISPLAY PORT OF THE MEGA DRIVE */
/* TAKING INTO ACCOUNT THE INTRICACIES OF THE SYSTEM THROUGH VARIOUS PIECES OF DOCUMENTATION */

/* DOCUMENTATION INCLUDES: */

/* https://wiki.megadrive.org/index.php?title=VDP */
/* http://md.railgun.works/index.php?title=VDP */
 
/* NESTED INCLUDES */

#include "68000.h"
#include "vdp.h"
#include "common.h"

/* CREATE AN INSTANCE OF THE VDP BY ALLOCING THE SCREEN BUFFER */
/* THIS WILL CREATE VIRTUAL MEMORY ASSOCIATED WITH THE BYTEWISE SIZE */
/* OF THE UNIT */

#undef USE_VDP

/* INITIALISE THE CORRESPONDING SIZE OF THE SPRITE TABLE */
/* THIS IS DONE AT RUNTIME TO EVALUATE HOW THE VDP WILL RENDER ON STARTUP */

void VDP_CONST_INIT(struct VDP* VDP, struct VDP_STATE* STATE, U16 PIXEL_LOOKUP[])
{
	for (int PIXEL_HIGH = 0; PIXEL_HIGH < VDP_SPRITE_LOOKUP; PIXEL_HIGH++)
	{
		for (int PIXEL_LOW = 0; PIXEL_LOW < VDP_SPRITE_LOOKUP; PIXEL_LOW++)
		{
			// INITIALISE THE SIZE OF THE PIXEL OUTPUT IN RELATION TO THE LOOKUP TABLE

			STATE->PIXEL_OUTPUT += 1, sizeof(STATE->PIXEL_OUTPUT += 1, sizeof(STATE->DRAW_PIXEL ? STATE->NEW_PIXEL : STATE->OLD_PIXEL)); 
			STATE->PIXEL_OUTPUT |= STATE->PIXEL_NO_SHADOW ? STATE->PIXEL_NO_SHADOW_MASK : 0;

			// DYNAMICALLY ALLOCATE THE SPRITE LOOKUP TABLE 
			// IN ACCORDANCE WITH THE CORRESPONDING PIXEL CONSTANTS

			malloc(sizeof(VDP_SPRITE_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH], PIXEL_LOOKUP[PIXEL_LOW] += STATE->PIXEL_OUTPUT));
			malloc(sizeof(VDP_SPRITE_DETAIL_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH], PIXEL_LOOKUP[PIXEL_LOW] += STATE->PIXEL_OUTPUT));
		}
	}
}

/* INITIALISE THE CORRESPONDING VALUES TOWARDS THE STRUCTURED VARIABLES */

void VDP_STATE_INIT(struct VDP_STATE* STATE)
{
	STATE->ACCESS_MODE.WRITE_PENDING = false;
	STATE->ACCESS_MODE.BUFFER = VDP_ACCESS_VRAM;
	STATE->ACCESS_MODE.READ_MODE = false;
	STATE->ACCESS_MODE.INDEXING = 0;
	STATE->ACCESS_MODE.INCREMENT = 0;

	STATE->DMA.ENABLED = false;
	STATE->DMA.PENDING = false;
	STATE->DMA.ADDRESS_MODE_HIGH = 0;
	STATE->DMA.ADDRESS_MODE_LOW = 0;

	STATE->PLANE_A_ADDRESS = 0;
	STATE->PLANE_B_ADDRESS = 0;
	STATE->WINDOW_ADDRESS = 0;
	STATE->SPRITE_TABLE = 0;
	STATE->HSCROLL_ADDRESS = 0;
	STATE->DISPLAY_ENABLED = false;
	STATE->VERTICAL_PLANE_ENABLED = false;
	STATE->HORI_PLANE_ENABLED = false;
	STATE->PLANE_WIDTH = 32;
	STATE->PLANE_HEIGHT = 32;
	STATE->PLANE_WIDTH_BITMASK = STATE->PLANE_WIDTH - 1;
	STATE->PLANE_HEIGHT_BITMASK = STATE->PLANE_HEIGHT - 1;

	STATE->H40_ENABLED = false;
	STATE->V30_ENABLED = false;
	STATE->SHADOW_ENABLED = false;
	STATE->SUPER_SAMPLING = false;

	STATE->BG_COLOUR = 0;
	STATE->HORI_INTERVAL = 0;
	STATE->VBLANK = 0;

	STATE->HSCROLL_MODE = VDP_HSCROLL_MODE_FULL;
	STATE->VSCROLL_MODE = VDP_VSCROLL_MODE_FULL;
}

/* RENDER THE TILESET BASED ON THE PLANE WIDTH AND HEIGHT */
/* THIS WILL TAKE INTO ACCOUNT THE METADATA NEEDED TO READ AND WRTIE TO */
/* TO THE RESPECTIVE PLANE ADDRESS */

void VDP_RENDER_TILE(struct VDP* VDP, struct VDP_STATE* VDP_STATE)
{
	struct VDP_TILE* TILE;
	U16 INDEX;
	U8 PIXEL_X, PIXEL_Y;

	U8 PALETTE_INDEX;

	/* FOR EACH RESPECTIVE ADDRESSABLE REGISTER FOR THE VDP */
	/* RENDER EACH TILE BASED ON THE INDEX IN THE PALETTE LINE */

	for (INDEX = 0; INDEX < 8; INDEX++)
	{
		/* THIS ASSUMES THE ROLE OF LOOKING THROUGH EACH INSTANCE */
		/* IN AN XOR BYTE ORDER */

		/* FROM THERE, IT EVALUATES THE NEXT CONCURRENT ELEMENT OUT OF 2 */
		/* AND INCREMENTS UNTIL THE CANVAS IS FILLED */

		PIXEL_X = INDEX ^ VDP_XOR_MODE;
		PALETTE_INDEX = PIXEL_X & 1 << 2;
		PALETTE_INDEX++;
	}
	
}
