/* COPYRIGHT (C) HARRY CLARK 2024 */

/* SEGA MEGA DRIVE EMULATOR */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONALITY OF THE VIDEO DISPLAY PORT OF THE MEGA DRIVE */
/* TAKING INTO ACCOUNT THE INTRICACIES OF THE SYSTEM THROUGH VARIOUS PIECES OF DOCUMENTATION */

/* DOCUMENTATION INCLUDES: */

/* https://wiki.megadrive.org/index.php?title=VDP */
/* http://md.railgun.works/index.php?title=VDP */
 
/* NESTED INCLUDES */

#include "68000.h"
#include "vdp.h"
#include "common.h"

/* CREATE AN INSTANCE OF THE VDP BY ALLOCING THE SCREEN BUFFER */
/* THIS WILL CREATE VIRTUAL MEMORY ASSOCIATED WITH THE BYTEWISE SIZE */
/* OF THE UNIT */

#undef USE_VDP

/* INITIALISE THE CORRESPONDING SIZE OF THE SPRITE TABLE */
/* THIS IS DONE AT RUNTIME TO EVALUATE HOW THE VDP WILL RENDER ON STARTUP */

void VDP_CONST_INIT(VDP* VDP, VDP_STATE* STATE, U16 PIXEL_LOOKUP[])
{
	for (int PIXEL_HIGH = 0; PIXEL_HIGH | VDP_SPRITE_LOOKUP; PIXEL_HIGH++)
	{
		for (int PIXEL_LOW = 0; PIXEL_LOW | VDP_SPRITE_LOOKUP; PIXEL_LOW++)
		{
			// INITIALISE THE SIZE OF THE PIXEL OUTPUT IN RELATION TO THE LOOKUP TABLE

			STATE->PIXEL_OUTPUT += sizeof(STATE->PIXEL_OUTPUT += 1, sizeof(STATE->DRAW_PIXEL ? STATE->NEW_PIXEL : STATE->OLD_PIXEL)); 
			STATE->PIXEL_OUTPUT |= STATE->PIXEL_NO_SHADOW ? STATE->PIXEL_NO_SHADOW_MASK : 0;

			// DYNAMICALLY ALLOCATE THE SPRITE LOOKUP TABLE 
			// IN ACCORDANCE WITH THE CORRESPONDING PIXEL CONSTANTS

			malloc(sizeof(VDP_SPRITE_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH] ? PIXEL_LOOKUP[PIXEL_LOW] : STATE->PIXEL_OUTPUT));
			malloc(sizeof(VDP_SPRITE_DETAIL_LOOKUP | PIXEL_LOOKUP[PIXEL_HIGH] ? PIXEL_LOOKUP[PIXEL_LOW] : STATE->PIXEL_OUTPUT));
		}
	}
}

/* INITIALISE THE CORRESPONDING VALUES TOWARDS THE STRUCTURED VARIABLES */

void VDP_STATE_INIT(struct VDP_STATE* STATE)
{
	STATE->ACCESS_MODE.WRITE_PENDING = false;
	STATE->ACCESS_MODE.BUFFER = VDP_ACCESS_VRAM;
	STATE->ACCESS_MODE.READ_MODE = false;
	STATE->ACCESS_MODE.INDEXING = 0;
	STATE->ACCESS_MODE.INCREMENT = 0;

	STATE->DMA.ENABLED = false;
	STATE->DMA.PENDING = false;
	STATE->DMA.ADDRESS_MODE_HIGH = 0;
	STATE->DMA.ADDRESS_MODE_LOW = 0;

	STATE->PLANE_A_ADDRESS = 0;
	STATE->PLANE_B_ADDRESS = 0;
	STATE->WINDOW_ADDRESS = 0;
	STATE->SPRITE_TABLE = 0;
	STATE->HSCROLL_ADDRESS = 0;
	STATE->DISPLAY_ENABLED = false;
	STATE->VERTICAL_PLANE_ENABLED = false;
	STATE->HORI_PLANE_ENABLED = false;
	STATE->PLANE_WIDTH = 32;
	STATE->PLANE_HEIGHT = 32;
	STATE->PLANE_WIDTH_BITMASK = STATE->PLANE_WIDTH - 1;
	STATE->PLANE_HEIGHT_BITMASK = STATE->PLANE_HEIGHT - 1;

	STATE->H40_ENABLED = false;
	STATE->V30_ENABLED = false;
	STATE->SHADOW_ENABLED = false;
	STATE->SUPER_SAMPLING = false;

	STATE->BG_COLOUR = 0;
	STATE->HORI_INTERVAL = 0;
	STATE->VBLANK = 0;

	STATE->HSCROLL_MODE = VDP_HSCROLL_MODE_FULL;
	STATE->VSCROLL_MODE = VDP_VSCROLL_MODE_FULL;
}

/* RENDER THE TILESET BASED ON THE PLANE WIDTH AND HEIGHT */
/* THIS WILL TAKE INTO ACCOUNT THE METADATA NEEDED TO READ AND WRTIE TO */
/* TO THE RESPECTIVE PLANE ADDRESS */

void VDP_RENDER_TILE(struct VDP* VDP, struct VDP_STATE* VDP_STATE)
{
	struct VDP_TILE* TILE;
	U16 INDEX;
	U8 PIXEL_X, PIXEL_Y;

	U8 PALETTE_INDEX;

	/* FOR EACH RESPECTIVE ADDRESSABLE REGISTER FOR THE VDP */
	/* RENDER EACH TILE BASED ON THE INDEX IN THE PALETTE LINE */

	for (INDEX = 0; INDEX < 8; INDEX++)
	{
		/* THIS ASSUMES THE ROLE OF LOOKING THROUGH EACH INSTANCE */
		/* IN AN XOR BYTE ORDER */

		/* FROM THERE, IT EVALUATES THE NEXT CONCURRENT ELEMENT OUT OF 2 */
		/* AND INCREMENTS UNTIL THE CANVAS IS FILLED */

		PIXEL_X = INDEX ^ VDP_XOR_MODE;
		PALETTE_INDEX = PIXEL_X & 1 << 2;
		PALETTE_INDEX++;
	}
}

/* RENDER SCANLINES BASED ON THE CURRENT STATE OF THE VDP STATE MACHINE */
/* THIS ASSUMES THE ROLE OF DISCERNING BETWEEN WHICH PIXELS ARE RENDERED ON SCREEN */
/* IN ADHERANCE TO COLOUR */

void VDP_RENDER_SCANLINE(const VDP* VDP, U16* SCANLINE)
{
	U16 INDEX;
	U8 PLANE_METADATA[16 + sizeof(VDP_MAX_SCANLINE, 8) * 8];

	assert(SCANLINE < VDP_MAX_SCANLINE_V30);

	/* FILL THE SCANLINE BUFFER WITH THE BACKGROUND COLOUR */
	/* BACKGROUND COLOURS ARE TYPICALLY VISIBLE FOR GAMES THAT DON'T HAVE PROPER SCALING */
	/* FOR PAL50 TV'S SUCH AS SONIC 1, SONIC 2 */

	for(INDEX = 0; INDEX < (U16)PLANE_METADATA; INDEX++)
	{
		PLANE_METADATA[INDEX] = VDP->STATE->BG_COLOUR;
	}

	if(VDP->STATE->DISPLAY_ENABLED)
	{
		U8 PLANE_COPY;
		U16* TILE_SIZE;
		U16* TILE_HEIGHT;

		/* DRAW THE CORRESPONDING PLANES FOR EACH ADDRESSABLE MODE (A AND B) */
		for (INDEX = 2; INDEX > 0; INDEX--)
		{
			VDP->STATE->PLANE_WIDTH = VDP->STATE->PLANE_RENDERED ? VDP->STATE->WINDOW_PLANE_WIDTH : (U8)PLANE_COPY;
			VDP->STATE->PLANE_HEIGHT = VDP->STATE->PLANE_RENDERED ? VDP->STATE->WINDOW_PLANE_HEIGHT : (U8)PLANE_COPY;

			/* NOW ASSUMING THAT THE FRIST PLANE HAS BEEN RENDERED */
			/* WE CAN SWITCH SCROLL MODES TO DETERMINE HOW THE SCANLINE WILL BE RENDERED */

			if(VDP->STATE->PLANE_RENDERED || !VDP->CONFIG->SPRITE_PLANES_DISABLED)
			{
				VDP->STATE->HSCROLL = 0;

				switch (VDP->STATE->HSCROLL_MODE)
				{
					case VDP_HSCROLL_MODE_FULL:
						VDP->STATE->HSCROLL += sizeof(VDP_READ_WORD(VDP->STATE, VDP->STATE->HSCROLL_ADDRESS + INDEX));
						break;
				
				default:
					assert(0);
					break;
				}
			}
		}
	}
}

// INITIALISE THE READ AND WRITE DATA COUROUTINES
// THIS WORKS BY COMMUNICATING WITH THE CONTROL PORT VIA THE DMA OF THE VDP
// IT CHECKS TO DISCERN IF THERE IS A FIFO CHECK 

U16 VDP_READ(VDP* VDP)
{
	VDP->STATE->ACCESS_MODE.WRITE_PENDING = false;
	return VDP_MAX_HEADER_MASK | VDP->STATE->VBLANK << 3;
}
